<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wangfulin&#39;s blog</title>
  <subtitle>Day day up</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangfulin.github.io/"/>
  <updated>2016-04-28T08:41:45.000Z</updated>
  <id>http://wangfulin.github.io/</id>
  
  <author>
    <name>wangfulin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>45个javascript技巧和最佳实践</title>
    <link href="http://wangfulin.github.io/2016/03/24/45-useful-javascript-tips-tricks-and-best-practices/"/>
    <id>http://wangfulin.github.io/2016/03/24/45-useful-javascript-tips-tricks-and-best-practices/</id>
    <published>2016-03-23T16:00:00.000Z</published>
    <updated>2016-04-28T08:41:45.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://modernweb.com/2013/12/23/45-useful-javascript-tips-tricks-and-best-practices/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;45 Useful Javascript Tips,Tricks and Best Practices&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs/45-useful-javascript-tips\keep-calm-and-learn-javascript.jpg&quot; alt=&quot;keep-calm-learn-js&quot;&gt;&lt;/p&gt;
&lt;p&gt;你知道的，Javascript是世界上第一的变成语言。它能够在web端，移动混合应用（像&lt;a href=&quot;http://phonegap.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PhoneGap&lt;/a&gt;和&lt;a href=&quot;http://www.appcelerator.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Appcelerator&lt;/a&gt;），以及服务端（&lt;a href=&quot;http://nodejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NodeJS&lt;/a&gt;和&lt;a href=&quot;http://wakanda.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wakanda&lt;/a&gt;）等其他地方都有应用。它也经常被用来当做很多世界上新的开发者的入门语言。它既能让我们在网页上展示弹窗，也能用来控制机器人。能够使用写出有组织，性能良好的javascript&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://modernweb.com/2013/12/23/45-useful-javascript-tips-tricks-and-best-practices/&quot; target=&quot;_
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://wangfulin.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>browserify简介</title>
    <link href="http://wangfulin.github.io/2016/02/24/broswerify/"/>
    <id>http://wangfulin.github.io/2016/02/24/broswerify/</id>
    <published>2016-02-23T16:00:00.000Z</published>
    <updated>2016-04-28T07:57:28.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/e19e230a9371a44a2eeb484b83ff4fcf8c824cf7/687474703a2f2f737562737461636b2e6e65742f696d616765732f62726f777365726966795f6c6f676f2e706e67&quot; alt=&quot;browserify&quot;&gt;&lt;br&gt;在浏览器中使用&lt;code&gt;require(&amp;#39;modules&amp;#39;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;node&lt;/code&gt;的风格来组织浏览器端的代码并且可以加载通过&lt;code&gt;npm&lt;/code&gt;安装的模块。&lt;/p&gt;
&lt;p&gt;browerify将递归分析你应用中所有的&lt;code&gt;require()&lt;/code&gt;调用去构建一个能够通过单个&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签引用的&lt;code&gt;js&lt;/code&gt;文件。&lt;/p&gt;
&lt;h2 id=&quot;如何开始&quot;&gt;&lt;a href=&quot;#如何开始&quot; class=&quot;headerlink&quot; title=&quot;如何开始&quot;&gt;&lt;/a&gt;如何开始&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;npm install -g browserify&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;创建modules&lt;ul&gt;
&lt;li&gt;创建foo.js&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;module.exports=function(n){return n*111;}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;创建bar.js&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;module.exports=function(s){return s+&amp;quot;!&amp;quot;;}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建main.js入口文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var foo=require(&amp;quot;foo.js&amp;quot;);
var bar=require(&amp;quot;bar.js&amp;quot;);
var str=foo(100)+bar(&amp;quot;bar&amp;quot;);
console.log(str);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;使用browerify命令预编译main.js&lt;blockquote&gt;
&lt;p&gt;browserify main.js &amp;gt; bundle.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/substack/node-browserify&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node-browerify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/substack/browserify-handbook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;browserify-handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/e19e230a9371a44a2eeb484b83ff4fcf8c824cf7/687474703a2f2f737562737461636b2e6e65742f696d6167657
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
    
      <category term="javascript, browserify" scheme="http://wangfulin.github.io/tags/javascript-browserify/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt;用CSS剪切圆形图片</title>
    <link href="http://wangfulin.github.io/2016/01/24/circular-image-with-css/"/>
    <id>http://wangfulin.github.io/2016/01/24/circular-image-with-css/</id>
    <published>2016-01-23T16:00:00.000Z</published>
    <updated>2016-04-28T08:46:13.000Z</updated>
    
    <content type="html">&lt;p&gt;在这个教程，我们会介绍一下使用CSS技巧来渲染出圆形的&lt;img&gt;元素，主要来实现这个效果的CSS属性是border-radius.&lt;/p&gt;
&lt;p&gt;尽管对于正方形的图片来实现圆形这个效果是相当简单的，但是对于长方形来说可能需要多一点点工作。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://wangfulin.github.io/imgs\circular-image-with-css\circular-images-lead.jpg&quot; alt=&quot;lead&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;正方形图片&quot;&gt;&lt;a href=&quot;#正方形图片&quot; class=&quot;headerlink&quot; title=&quot;正方形图片&quot;&gt;&lt;/a&gt;正方形图片&lt;/h2&gt;&lt;p&gt;一个百分百正方形的img标签要变成圆形的只需要一行CSS代码。这个技巧在正方形图片上使用的最方便。&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img class=&amp;quot;circle--square&amp;quot; src=&amp;quot;woman.png&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.circular--squareP{
    border-radius:50%;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过设置img标签的所有的border-radius属性为正方形宽/高的50%，我们就可以把这个img标签变成圆的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\circular-image-with-css\circular-image-square.png&quot; alt=&quot;square&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;长方形图片&quot;&gt;&lt;a href=&quot;#长方形图片&quot; class=&quot;headerlink&quot; title=&quot;长方形图片&quot;&gt;&lt;/a&gt;长方形图片&lt;/h2&gt;&lt;p&gt;长方形图片会稍微有一点技巧一点。&lt;/p&gt;
&lt;p&gt;去渲染一个圆形，必须以圆形图片为基础&lt;/p&gt;
&lt;p&gt;要解决这个问题，我们可以通过在img标签外面套一层div，然后我们通过将超过这个外层div的img标签的内容给裁掉来实现。具体的话可以通过将外层div的overflow属性设置为hidden。&lt;/p&gt;
&lt;p&gt;为了能够让照片的主题不要被裁掉，我们必须要区别对待水平和垂直方向的图片。&lt;/p&gt;
&lt;h3 id=&quot;水平方向的图片&quot;&gt;&lt;a href=&quot;#水平方向的图片&quot; class=&quot;headerlink&quot; title=&quot;水平方向的图片&quot;&gt;&lt;/a&gt;水平方向的图片&lt;/h3&gt;&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;img src=&amp;quot;images/brack-obama.png&amp;quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.circular--landscape{
    display:inline-block;
    position:relative;
    width:200px;
    height:200px;
    overflow:hidden;
    border-radius:50%;
}

.circular--landscape img{
    width:auto;
    height:100%;
    margin-left:-50%;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;高度和宽度属性必须要保持一样来确保这个div（.circular–landscape）能够作为正方形渲染起来&lt;/p&gt;
&lt;p&gt;除此之外，高度和宽度属性必须要等于或者小于img的高度。这能够确保img元素能够占满外层div而不会多出一部分空白&lt;/p&gt;
&lt;p&gt;一般来说，水平方向图片的主题（但不一定）会位于图片的中心位置。为了能够让我们尽量不会把图片的主题裁剪啦，我们可以通过把图片往左移来弥补图片剪切的内容有点偏右的问题。&lt;/p&gt;
&lt;p&gt;我们移动img标签的大小是外层div的25%，在这个例子中就是向左50px，我们可以通过设置margin-left的属性来完成设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;margin-left:-50px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\circular-image-with-css\circular-image-landscape-mode.png&quot; alt=&quot;landscape&quot;&gt;&lt;/p&gt;
&lt;p&gt;图片的主题会接近图片的水平方向中心的假设并不一定是对的，最好在你选择使用这个技巧的使用把这个假设记住。&lt;/p&gt;
&lt;h3 id=&quot;垂直方向的图片&quot;&gt;&lt;a href=&quot;#垂直方向的图片&quot; class=&quot;headerlink&quot; title=&quot;垂直方向的图片&quot;&gt;&lt;/a&gt;垂直方向的图片&lt;/h3&gt;&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;img src=&amp;quot;images/woman-portrait.png&amp;quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.circular--portrait{
    position:relative;
    width:200px;
    height:200px;
    overflow:hidden;
    border-radius:50%;
}

.circular--portrait img{
    width:100%;
    height:auto;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于垂直方向上的图片的主题在垂直方向的中心的假设当然也不适用于每一个垂直方向上的图片。&lt;/p&gt;
&lt;p&gt;和水平方向的图片类似，外层div的宽度和高度最好等于垂直方向图片你的宽度，这样的话可以产生最好的效果。&lt;/p&gt;
&lt;p&gt;对于垂直方向的图片，我们把宽度设置为100%，高度设置为auto（和水平方向的图片相反）&lt;/p&gt;
&lt;p&gt;我们不需要移动这个img元素，因为这张照片的主题就在上方中心位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\circular-image-with-css\circular-image-portrait.png&quot; alt=&quot;portrait&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;p&gt;这个技巧最好适用于正方形的img标签，主题正好位于图片的中心。但是，我们的世界并不是那么完美的，所有如果需求是这样，我们就可以使用div来把长方形img标签变圆。&lt;/p&gt;
&lt;p&gt;CSS中用来负责把图片变圆的属性是border-radius，把边的圆角变成高度/宽度的50%就可以产生一个圆。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://sixrevisions.com/css/circular-images-css/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;circular-images-css&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在这个教程，我们会介绍一下使用CSS技巧来渲染出圆形的&lt;img&gt;元素，主要来实现这个效果的CSS属性是border-radius.&lt;/p&gt;
&lt;p&gt;尽管对于正方形的图片来实现圆形这个效果是相当简单的，但是对于长方形来说可能需要多一点点工作。&lt;/p&gt;
&lt;p&gt; &lt;img src=
    
    </summary>
    
      <category term="CSS" scheme="http://wangfulin.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://wangfulin.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt;深入了解CSS Box Shadow</title>
    <link href="http://wangfulin.github.io/2015/12/24/css-box-shadow/"/>
    <id>http://wangfulin.github.io/2015/12/24/css-box-shadow/</id>
    <published>2015-12-23T16:00:00.000Z</published>
    <updated>2016-04-28T08:41:35.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://sixrevisions.com/css/css-box-shadow/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Close Look at CSS Box Shadow&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CSS的&lt;code&gt;box-shadow&lt;/code&gt;可以被用来给块级元素一个外阴影或者是内阴影。接下来让我们仔细地看一下这个CSS的特性吧。&lt;/p&gt;
&lt;h2 id=&quot;举例&quot;&gt;&lt;a href=&quot;#举例&quot; class=&quot;headerlink&quot; title=&quot;举例&quot;&gt;&lt;/a&gt;举例&lt;/h2&gt;&lt;p&gt;下面有三个把CSS的&lt;code&gt;box-shadow&lt;/code&gt;属性使用在&lt;code&gt;div&lt;/code&gt;里的例子。&lt;/p&gt;
&lt;p&gt;###　例１：简单的外阴影&lt;/p&gt;
&lt;p&gt;下面是是给副标题添加阴影的样式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:0 0 10px gray;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\basic-box-shadow-example.png&quot; alt=&quot;simple-drop-shadow&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;例2：内阴影&quot;&gt;&lt;a href=&quot;#例2：内阴影&quot; class=&quot;headerlink&quot; title=&quot;例2：内阴影&quot;&gt;&lt;/a&gt;例2：内阴影&lt;/h3&gt;&lt;p&gt;一个内阴影可以通过使用inset属性值来渲染出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:inset 0 0 10px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\basic-inset-box-shadow-example.png&quot; alt=&quot;inner-shadow&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;例3：偏移外阴影&quot;&gt;&lt;a href=&quot;#例3：偏移外阴影&quot; class=&quot;headerlink&quot; title=&quot;例3：偏移外阴影&quot;&gt;&lt;/a&gt;例3：偏移外阴影&lt;/h3&gt;&lt;p&gt;这个例子中我们通过水平和垂直方向下和右偏移5px来实现阴影向右下方偏移&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:5px 5px 10px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\offset-box-shadow-example-01.png&quot; alt=&quot;offset-drop-shadow-bottom-right&quot;&gt;&lt;/p&gt;
&lt;p&gt;加入你想要阴影向左上方偏移呢？我们可以通过将水平和垂直方向的偏移量设置为-5px，正如下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:-5px -5px 10px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\offset-box-shadow-example-02.png&quot; alt=&quot;offset-drop-shadow-top-left&quot;&gt;&lt;/p&gt;
&lt;p&gt;既然你已经看到了&lt;code&gt;box-shadow&lt;/code&gt;在现实中的使用，接下来让我们更加深入地了解一下。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;&lt;code&gt;box-shadow&lt;/code&gt;的一般语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:[inset] [horizontal offset] [vertical 
offset] [blur radius] [spread distance] [color]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;CSS属性值&quot;&gt;&lt;a href=&quot;#CSS属性值&quot; class=&quot;headerlink&quot; title=&quot;CSS属性值&quot;&gt;&lt;/a&gt;CSS属性值&lt;/h2&gt;&lt;p&gt;CSS的&lt;code&gt;box-shadow&lt;/code&gt;可能会有6个属性值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;inset&lt;/li&gt;
&lt;li&gt;horizontal offset&lt;/li&gt;
&lt;li&gt;vertical offset&lt;/li&gt;
&lt;li&gt;blur radius&lt;/li&gt;
&lt;li&gt;spread distance&lt;/li&gt;
&lt;li&gt;color&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只有两个属性是必须的：水平偏移和垂直偏移量。&lt;/p&gt;
&lt;p&gt;四个属性值，水平偏移，垂直偏移，模糊半径，扩展距离，必须使用CSS长度单元（比如：px,em,%等）&lt;/p&gt;
&lt;p&gt;这个颜色值必须是必须是一个颜色单元，比如十六进制值（如：#000000）。&lt;/p&gt;
&lt;h3 id=&quot;属性和值总结表&quot;&gt;&lt;a href=&quot;#属性和值总结表&quot; class=&quot;headerlink&quot; title=&quot;属性和值总结表&quot;&gt;&lt;/a&gt;属性和值总结表&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;th&gt;单位&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;inset&lt;/td&gt;
&lt;td&gt;不是&lt;/td&gt;
&lt;td&gt;关键词&lt;/td&gt;
&lt;td&gt;没有指定的时候，阴影默认在外面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;水平偏移&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;长度&lt;/td&gt;
&lt;td&gt;没有默认值，一定有指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;垂直偏移&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;长度&lt;/td&gt;
&lt;td&gt;没有默认值，一定要指定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;模糊半径&lt;/td&gt;
&lt;td&gt;不是&lt;/td&gt;
&lt;td&gt;长度&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;扩展距离&lt;/td&gt;
&lt;td&gt;不是&lt;/td&gt;
&lt;td&gt;长度&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;颜色&lt;/td&gt;
&lt;td&gt;不是&lt;/td&gt;
&lt;td&gt;颜色&lt;/td&gt;
&lt;td&gt;和box shadow属性作用的元素的color值一样&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;inset&quot;&gt;&lt;a href=&quot;#inset&quot; class=&quot;headerlink&quot; title=&quot;inset&quot;&gt;&lt;/a&gt;inset&lt;/h2&gt;&lt;p&gt;如果&lt;code&gt;inset&lt;/code&gt;关键词存在，盒阴影将会放在HTML元素的内部&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:inset 0 0 5px 5px olive;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\css-box-shadow-inset-property.png&quot; alt=&quot;inset-shadow&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为对比，这里是一个没有&lt;code&gt;inset&lt;/code&gt;属性的&lt;code&gt;box-shadow&lt;/code&gt;样式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:0 0 5px 5px olive;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\css-box-shadow-no-inset-property.png&quot; alt=&quot;no-inset-shadow&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;水平偏移&quot;&gt;&lt;a href=&quot;#水平偏移&quot; class=&quot;headerlink&quot; title=&quot;水平偏移&quot;&gt;&lt;/a&gt;水平偏移&lt;/h3&gt;&lt;p&gt;水平偏移控制了盒子阴影在x轴的偏移。正值会把盒子的阴影向右移动，负值的话会把它向左移动。&lt;/p&gt;
&lt;p&gt;下面的例子中，我们把水平的偏移设置成20px，刚好是水平偏移量的两倍，所以阴影水平宽度刚好是垂直高度的两倍。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:20px 10px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\css-box-shadow-horizontal-offset-property.png&quot; alt=&quot;horizontal offset value&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;垂直偏移&quot;&gt;&lt;a href=&quot;#垂直偏移&quot; class=&quot;headerlink&quot; title=&quot;垂直偏移&quot;&gt;&lt;/a&gt;垂直偏移&lt;/h3&gt;&lt;p&gt;垂直偏移控制了盒阴影在y轴的偏移量。正值会把盒子的阴影向下移动，负值刚好相反会把盒子网上移动。&lt;/p&gt;
&lt;p&gt;下面的例子中，垂直的偏移设置成-20px，刚好是水平偏移的两倍。同时，因为是负值，所以向上移动。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:10px -20px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\css-box-shadow-vertical-offset-property.png&quot; alt=&quot;vertical offset value&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;模糊半径&quot;&gt;&lt;a href=&quot;#模糊半径&quot; class=&quot;headerlink&quot; title=&quot;模糊半径&quot;&gt;&lt;/a&gt;模糊半径&lt;/h3&gt;&lt;p&gt;这个模糊半径会影响到阴影的模糊和锐利程度。&lt;/p&gt;
&lt;p&gt;模糊半径是可选的，如果你不指定它，默认值是0.另外，你不能指定它为负值，这个和水平偏移和垂直偏移不一样。&lt;/p&gt;
&lt;p&gt;如果模糊半径是0，盒子阴影会很锐利并且它的颜色是很实的。随着你不断的增大这个值，它会变得越来越模糊和透明。&lt;/p&gt;
&lt;p&gt;下面的例子，模糊半径被设置成20px，因此模糊度是相当突出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:5px 5px 20px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\css-box-shadow-blur-radius.png&quot; alt=&quot;css-box-shadow-blur-radius&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;扩展距离&quot;&gt;&lt;a href=&quot;#扩展距离&quot; class=&quot;headerlink&quot; title=&quot;扩展距离&quot;&gt;&lt;/a&gt;扩展距离&lt;/h3&gt;&lt;p&gt;这个扩展距离会让盒子的阴影在各个方向上都会变大或变小。如果它有一个正值，盒子阴影会在各个方向上增加大小。如果是负值，则会在各个方向上收缩。&lt;/p&gt;
&lt;p&gt;值得注意的是，因为它的扩展距离是正5，所以会在各个方向上增加10px因为没有水平和垂直偏移。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:0 0 10px 5px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\css-box-shadow-spread-distance.png&quot; alt=&quot;css-box-shadow-spread-distance&quot;&gt;&lt;/p&gt;
&lt;p&gt;当扩展距离是负的时候，阴影就会在各个方向上收缩。下面的例子展示当阴影的宽度比盒子小的时候的情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow:0 10px 10px -5px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\css-box-shadow-negative-spread-distance.png&quot; alt=&quot;css-box-shadow-negative-spread-distance&quot;&gt;&lt;/p&gt;
&lt;p&gt;###　颜色&lt;/p&gt;
&lt;p&gt;通过名字你就可以判断出来，颜色值会设置盒阴影的颜色。它可以通过任何可以表示颜色的方式来表示颜色。是否设置颜色值是可选的。&lt;/p&gt;
&lt;p&gt;换句话说，默认情况下当你没有指明颜色值，阴影颜色会等于这个盒子对应的html元素的颜色值。比如有一个&lt;code&gt;div&lt;/code&gt;的颜色被设置成红色，这个盒子阴影的颜色也会变成红色：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;color:red;
box-shadow:0 0 10px 5px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\css-box-shadow-default-color.png&quot; alt=&quot;css-box-shadow-default-color&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你想要设置阴影的颜色和&lt;code&gt;div&lt;/code&gt;的颜色不一样，可以通过下面的方式，你会发现尽管你的文字颜色是红色，盒子阴影颜色依然可以是蓝色。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;color:red;
box-shadow:0 0 10px 5px blue;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\css-box-shadow-color-specified.png&quot; alt=&quot;css-box-shadow-color-specified&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;多阴影效果&quot;&gt;&lt;a href=&quot;#多阴影效果&quot; class=&quot;headerlink&quot; title=&quot;多阴影效果&quot;&gt;&lt;/a&gt;多阴影效果&lt;/h2&gt;&lt;p&gt;这个就是能够让我们变得有创造力的CSS属性。你能够在一个盒子上设置多个阴影。&lt;/p&gt;
&lt;p&gt;语法就像下面这样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow: [box shadow properties 1],
 [box shadow properties 2],
 [box shadow properties n];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;换句话说，你可以通过在每个属性设置组后面添加逗号(,)来实现多阴影。&lt;/p&gt;
&lt;p&gt;下面的例子展示了两个阴影的情况，左上方红色的阴影，右下方蓝色的阴影。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-shadow: -5px -5px 30px 5px red,
         5px 5px 30px 5px blue;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\multiple-box-shadows.png&quot; alt=&quot;multiple-box-shadows&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;浏览器支持&quot;&gt;&lt;a href=&quot;#浏览器支持&quot; class=&quot;headerlink&quot; title=&quot;浏览器支持&quot;&gt;&lt;/a&gt;浏览器支持&lt;/h2&gt;&lt;p&gt;这个CSS的&lt;code&gt;box-shadow&lt;/code&gt;属性有着很好地浏览器支持。使用这个属性在拖后腿的IE浏览器也能在IE9以后得到支持啦。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.sixrevisions.com/0457-01-css-box-shadow-demo/demo.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;查看演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-box-shadow\css-box-shadow-examples.png&quot; alt=&quot;css-box-shadow-example&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://sixrevisions.com/css/css-box-shadow/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Close Look at CSS
    
    </summary>
    
      <category term="CSS" scheme="http://wangfulin.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://wangfulin.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt;聊一聊CSS方法论</title>
    <link href="http://wangfulin.github.io/2015/11/20/css-methodologies/"/>
    <id>http://wangfulin.github.io/2015/11/20/css-methodologies/</id>
    <published>2015-11-19T16:00:00.000Z</published>
    <updated>2016-04-28T08:41:42.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;a href=&quot;&quot;&gt;A Look at Some CSS methodologies&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CSS在大型，复杂，快速迭代的系统中难以管理的程度是出了名的。&lt;/p&gt;
&lt;p&gt;其中一个原因是CSS缺少内置的作用域管理机制。在CSS中，所有的一切都是全局的，这意味着任何你所做的改变都有可能层叠或者改变完全没有相关的那部分UI。&lt;/p&gt;
&lt;p&gt;扩展的CSS语言，也称作&lt;a href=&quot;http://sixrevisions.com/elsewhere-on-the-web/the-best-css-preprocessors-right-now/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS预处理器&lt;/a&gt;，比如说Sass，Less和Stylus，通过增加一些新的特性让写CSS代码变得更简单一点。但是就算有这些扩展性的CSS语言，在我看来，也并没有解决可扩展性问题。&lt;/p&gt;
&lt;p&gt;在CSS没有自己的作用域机制之前，我们不得不设计出自己的一套系统来防止HTML文档的特定区域不被收到影响。&lt;/p&gt;
&lt;p&gt;下面是关于CSS方法论的介绍可能让我们找到一些答案。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们来看看这些CSS方法论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向对象的CSS（Object-Oriented CSS(OOCSS)）&lt;/li&gt;
&lt;li&gt;块，元素，修饰符（Block,Element,Modifier(BEM)）&lt;/li&gt;
&lt;li&gt;可扩展性和模块化性CSS架构（Scalable and Modular Architecture for CSS(SMACSS)）&lt;/li&gt;
&lt;li&gt;SUIT CSS&lt;/li&gt;
&lt;li&gt;系统化CSS（Systematic CSS）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSS方法论是正式的，文档化写CSS的方法系统，它能够让我们以一系列小的，独立的方式来开发，维护和扩展前端代码。而不是作为一大块整体的不可分割的代码。&lt;/p&gt;
&lt;p&gt;采用一种CSS方法论，甚至是你自己创建的一种，无论项目的大小和复杂度都会让CSS变得更好设计并且更好地在设计项目中迭代。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关：&lt;/strong&gt;&lt;a href=&quot;http://sixrevisions.com/css/css-development-at-large-sites/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大型网站的CSS开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每一种CSS方法论都提供了一系列略微不同的解决CSS可扩展性/可维护性的方法。一个CSS方法论通常会定义一些指南：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS和HTML最佳实践&lt;/li&gt;
&lt;li&gt;Class和ID命名规范&lt;/li&gt;
&lt;li&gt;CSS样式规则的排序和组合&lt;/li&gt;
&lt;li&gt;代码格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;世界上并没有“最佳”的CSS方法论。不同的方法适应于不同的个人/项目组/项目。&lt;/p&gt;
&lt;p&gt;我们希望的是，通过了解目前已经存在的CSS方法论可以帮助我们找到一种适应我们需求的方法。或者它也许能激发你的创造力，让你创建一个你自己专属的CSS方法论。&lt;/p&gt;
&lt;h2 id=&quot;面向对象的CSS（OOCSS）&quot;&gt;&lt;a href=&quot;#面向对象的CSS（OOCSS）&quot; class=&quot;headerlink&quot; title=&quot;面向对象的CSS（OOCSS）&quot;&gt;&lt;/a&gt;面向对象的CSS（OOCSS）&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\css-methodologies\object-oriented-css.png&quot; alt=&quot;lines and grids&quot;&gt;&lt;/p&gt;
&lt;p&gt;Nicole Sullivan的面向对象的CSS，或者简单来说OOCSS，在2009年发布。&lt;/p&gt;
&lt;p&gt;这实际上是第一个大范围采用的CSS方法论。甚至到现在也有很大的影响力。&lt;/p&gt;
&lt;p&gt;OOCSS鼓励结构和样式的分离。这个方法论在内容和容器之间有着明显的区分。&lt;/p&gt;
&lt;p&gt;在OOCSS中，样式规则只由CSS类选择器来写。&lt;/p&gt;
&lt;h3 id=&quot;OOCSS例子&quot;&gt;&lt;a href=&quot;#OOCSS例子&quot; class=&quot;headerlink&quot; title=&quot;OOCSS例子&quot;&gt;&lt;/a&gt;OOCSS例子&lt;/h3&gt;&lt;p&gt;比如你的button元素的样式可能有两个CSS类来设置，比如下面这两个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.button – 提供button的基本结构&lt;/li&gt;
&lt;li&gt;.grey-btn – 提供颜色和其他视觉样式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CSS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.button{
    box-sizing:border-box;
    height:50px;
    width:100%;
}
.grey-btn{
    background:#EEE;
    border:1px solid #DDD;
    box-shadow:rgba(0,0,0,0.5) 1px 1px 3px;
    color:#555;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button class=&amp;quot;button grey-btn&amp;quot;&amp;gt;&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;反例&quot;&gt;&lt;a href=&quot;#反例&quot; class=&quot;headerlink&quot; title=&quot;反例&quot;&gt;&lt;/a&gt;反例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/* 后代选择器在OOCSS中是不被提倡的 */
.wrapper .blog-post .button{
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过这种方式，HTML元素的样式表现就不会依赖于其所在的特定DOM结构上，也就不会受到位置的影响。&lt;/p&gt;
&lt;p&gt;OOCSS方法论这样做的最大好处就是它能够让作者最大的利用CSS层叠的样式的好处，而不是把它锁在高度具体的选择器中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关：&lt;/strong&gt;&lt;a href=&quot;http://sixrevisions.com/css/css-specificity/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS特性是怎么工作的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者鼓励我们无论何时都去复用已有的样式而不是创建新的样式。我们也被鼓励通过新的类来扩展样式而不是修改或者覆盖已有的CSS样式。&lt;/p&gt;
&lt;h3 id=&quot;反例-1&quot;&gt;&lt;a href=&quot;#反例-1&quot; class=&quot;headerlink&quot; title=&quot;反例&quot;&gt;&lt;/a&gt;反例&lt;/h3&gt;&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 反例  --&amp;gt;
&amp;lt;ul class=&amp;quot;to-do&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;Combine my CSS files&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Run CSS Lint&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Minify my stylesheet&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*  反例 */
.to-do{
    color:#FFF;
    background-color:#000;
}
.to-do li:first-child{
    color:#FF0000;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OOCSS例子&lt;/p&gt;
&lt;p&gt;为了让我们的CSS更具模块化和灵活度，并且防止出现后代选择器，我们用下面的方式来复写上面的反例：&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- OOCSS --&amp;gt;
&amp;lt;ul class=&amp;quot;to-do&amp;quot;&amp;gt;
      &amp;lt;li class=&amp;quot;first-to-do-    item&amp;quot;&amp;gt;Combine my CSS files&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;Run CSS Lint&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;Minify my stylesheet&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* OOCSS */
.to-do {
      color: #FFF;
      background-color: #000;
}
.first-to-do-item {
      color: #FF0000;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OOCSS的弱点是你很可能会使用很多很多的类，到最后你都无法维护或管理啦。&lt;/p&gt;
&lt;p&gt;并且，在我看来，让OOCSS产生灵感的面向对象编程的思想在CSS中并不契合。&lt;/p&gt;
&lt;p&gt;但是，这并不是说OOCSS的原则是无效的。相反，OOCSS是把大型CSS开发带来理性的常用的CSS方法论.&lt;/p&gt;
&lt;h2 id=&quot;块，元素，修饰符&quot;&gt;&lt;a href=&quot;#块，元素，修饰符&quot; class=&quot;headerlink&quot; title=&quot;块，元素，修饰符&quot;&gt;&lt;/a&gt;块，元素，修饰符&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;imgs/css-methodologies/bem-methodology.png&quot; alt=&quot;block,element,modifier&quot;&gt;&lt;/p&gt;
&lt;p&gt;块，元素，修饰符－－更常被叫做BEM–是一个由被称为俄罗斯的谷歌的Yandex开发组开发的一套CSS体系。&lt;/p&gt;
&lt;p&gt;在BEM背后的思想是区分实现不同角色的CSS类。这是通过把CSS命名为表示其角色的类名。&lt;/p&gt;
&lt;p&gt;BEM刚好可以作为OOCSS的补充，因为OOCSS并没有施加任何的命名规范。&lt;/p&gt;
&lt;p&gt;在BEM的方法论中，一个&lt;strong&gt;块&lt;/strong&gt;是一个独立的模块好的UI组件。一个块可以由多个HTML元素组成，甚至有几个块组合而成。比如说导航菜单和搜索表单就是一个块的例子。&lt;/p&gt;
&lt;p&gt;一个&lt;strong&gt;元素&lt;/strong&gt;就是块的一个组件。一个元素一般用来完成一个目的。比如说，你有一个导航菜单块，那导航菜单的链接就是元素，它可以使一个列表项(li元素)或者链接(a元素).&lt;/p&gt;
&lt;p&gt;一个修饰符是用来改变块或者元素默认样式的CSS类。&lt;/p&gt;
&lt;p&gt;喜爱案就是BEM类命名的语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.block&lt;/li&gt;
&lt;li&gt;.block–modifier&lt;/li&gt;
&lt;li&gt;.block__element&lt;/li&gt;
&lt;li&gt;.block__element–modifier&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;反例-2&quot;&gt;&lt;a href=&quot;#反例-2&quot; class=&quot;headerlink&quot; title=&quot;反例&quot;&gt;&lt;/a&gt;反例&lt;/h3&gt;&lt;p&gt;考虑下面的例子，标记代表的是一个登录表单：&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form&amp;gt;
    &amp;lt;label&amp;gt;
    username &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; /&amp;gt;
    &amp;lt;/label&amp;gt;
    &amp;lt;label&amp;gt;
        password &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; /&amp;gt;
    &amp;lt;/label&amp;gt;
    &amp;lt;button&amp;gt;
        Sign in
    &amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;BEM范例&quot;&gt;&lt;a href=&quot;#BEM范例&quot; class=&quot;headerlink&quot; title=&quot;BEM范例&quot;&gt;&lt;/a&gt;BEM范例&lt;/h3&gt;&lt;p&gt;下面是使用BEM命名规则来为上面的标记命名：&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form class=&amp;quot;loginform loginform--errors&amp;quot;&amp;gt;
    &amp;lt;label class=&amp;quot;loginform__username loginform__username--error&amp;quot;&amp;gt;
Username &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot; /&amp;gt;
    &amp;lt;/label&amp;gt;
    &amp;lt;label class=&amp;quot;loginform__password&amp;quot;&amp;gt;
Password &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot; /&amp;gt;
    &amp;lt;/label&amp;gt;
   &amp;lt;button class=&amp;quot;loginform__btn loginform__btn--inactive&amp;quot;&amp;gt;
            Sign in
    &amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个.loginform类是一个块。&lt;br&gt;这个.loginform块由三个元素组成：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;strong&gt;元素&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;loginform__username&lt;/td&gt;
&lt;td&gt;代表用户名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;loginform__password&lt;/td&gt;
&lt;td&gt;代表密码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;loginform__btn&lt;/td&gt;
&lt;td&gt;用户点击提交表单&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这三个修饰符分别是：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;修饰符&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.loginform__username–errror&lt;/td&gt;
&lt;td&gt;错误时的样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.loginform__btn–inactive&lt;/td&gt;
&lt;td&gt;未激活样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.loginform–errors&lt;/td&gt;
&lt;td&gt;包含错误的样式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这种BEM的命名规则帮助CSS的作者遵循OOCSS的原则。通过使用这种扁平的命名方式避免了多后代的选择器。&lt;/p&gt;
&lt;h3 id=&quot;反例-3&quot;&gt;&lt;a href=&quot;#反例-3&quot; class=&quot;headerlink&quot; title=&quot;反例&quot;&gt;&lt;/a&gt;反例&lt;/h3&gt;&lt;p&gt;所以我们不会用下面这种样式命名规则。。。&lt;/p&gt;
&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loginform .username .error{
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;BEM范例-1&quot;&gt;&lt;a href=&quot;#BEM范例-1&quot; class=&quot;headerlink&quot; title=&quot;BEM范例&quot;&gt;&lt;/a&gt;BEM范例&lt;/h3&gt;&lt;p&gt;。。。你只需要一个类选择器：&lt;/p&gt;
&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.loginform__username--error{
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BEM是一个非常鲁棒的命名规范。&lt;/p&gt;
&lt;p&gt;它成功地区分了类的不同关注点。并且通过类名我们可以很简单的看到标记之间的关系。&lt;/p&gt;
&lt;p&gt;一些关于BEM的主观批评如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类名会变的很长很难看&lt;/li&gt;
&lt;li&gt;命名规范对于没有经验的开发者来说不是那么的好理解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为个人来讲，我倒不认为这是特别强烈的批评。但是如果有一个能够和BEM一样鲁棒的命名规范同时能够更简洁和好理解那就更好啦。&lt;/p&gt;
&lt;p&gt;待续。。。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;a href=&quot;&quot;&gt;A Look at Some CSS methodologies&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CSS在大型，复杂，快速迭代的系统中难以管理的程度是出了名的。&lt;/
    
    </summary>
    
      <category term="CSS" scheme="http://wangfulin.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://wangfulin.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt; 单例模式</title>
    <link href="http://wangfulin.github.io/2015/11/10/Singleton-Pattern/"/>
    <id>http://wangfulin.github.io/2015/11/10/Singleton-Pattern/</id>
    <published>2015-11-09T16:00:00.000Z</published>
    <updated>2016-04-28T08:00:39.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Single Pattern&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单例模式被熟知是因为它把一个类的实例化限制在只有一个对象。传统的实现方式是：创建一个类，这个类里面有一个方法在对象不存在的时候创造一个实例，存在的时候，只需要返回这个对象的引用即可。&lt;/p&gt;
&lt;p&gt;单例和静态类（或者对象）是有区别的，因为我们可以延迟他们的初始化。因为他们需要一些在初始化的时候不能获得的信息。他们没有提供一种方式让不知道他们之前引用的代码去获取他们。这是因为由单例返回的既不是对象也不是类，而是一种结构。想想大括号形成的不是真正的闭包，函数作用于提供的闭包才是真正的闭包。&lt;/p&gt;
&lt;p&gt;Javascript中，单例作为共享资源的命名空间，它隔离了实现的代码和全局变量，为了能够让函数有唯一的一个入口。&lt;/p&gt;
&lt;p&gt;我们可以通过下面的方法实现单例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var mySingleton=(function(){
    //存储单例引用的实例
    var instance;

    function init(){
        //单例

        //私有方法和属性
        function privateMethod(){
            console.log(&amp;quot;I am private);
        }

        var privateVariable=&amp;quot;I&amp;apos;m alse private&amp;quot;;

        var privateRandomNumber=Math.random();

        return {
            //公有方法和属性
            publicMethod:function(){
                console.log(&amp;quot;The public can see me!);
            },
            publicProperty:&amp;quot;I am also public&amp;quot;,
            getRandomNumber:function(){
                return privateRandomNumber;
            }
        };
    }

    return {

        //如果存在获取单例实例的引用
        //不存在，创建实例
        getInstance:function(){
            if(!instance){
                instance=init();
            }
            return instance;
        }
    };

})();

var myBadSingleton=(function(){
    //指向单例的引用
    var instance;

    function init(){
        //单例
        var privateRandomNumber=Math.random();

        return {
            getRandomNumber:function(){
                return privateRandomNumber;
            }
        }
    }

    return {
        //无论什么时候都创建一个单例实例
        getInstance:function(){
            instance=init();

            return instance;
        }
    };
})();

//使用：

var singleA=mySingleton.getInstance();
var singleB=mySingleton.getInstance();
console.log(singA.getRandomNumber()===singleB.getRandomNumber()); //true

var badSingleA=myBadSingleton.getInstance();
var badSingleB=myBadSingleton.getInstance();
console.log(badSingleA.getRandomNumber()!==badSingleB.getRandomNumber());//true

//注意：因为我们使用的是随机数
//所以上面的值还是有可能相同的
//但是可能性很低，上面的例子还是有效的。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用单例可以让我们有一个指向实例的统一入口（一般通过&lt;code&gt;MySingleton.getInstance()&lt;/code&gt;的方式），这样我们就不需要直接通过&lt;code&gt;new MySingleton()&lt;/code&gt;的方式直接调用啦。这在javascript中也是可以实现的。&lt;/p&gt;
&lt;p&gt;在四人帮这本书中，单例的适用场景被描述为下面这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;必须只有一个类的实例，而且必须可以通过大家都知道的入口让大家可以访问到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当这个唯一的实例需要被之类扩展的时候，用户可以在不需要修改代码的情况下扩展它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二点指出了我们可能遇到的场景，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mySingleton.getInstance=function(){
    if(this._instance==null){
        if(isFoo()){
            this._instance=new FooSingleton();
        }else{
            this._instance=new BasicSingleton();
        }
    }
    return this._instance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里，&lt;code&gt;getInstance&lt;/code&gt;变得有些像工厂方法，我们访问它的时候并不需要更新我们的每一部分代码。上面的&lt;code&gt;FooSingleton&lt;/code&gt;可能是&lt;code&gt;BasicSingleton&lt;/code&gt;的之类，并且实现了同样的接口。&lt;/p&gt;
&lt;p&gt;为什么在单例中延迟执行被认为很重要呢？：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在C++中，它被用来让我们解决动态初始化执行顺序的不可预测性，把控制权交给了程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是区分类的静态实例和单例的区别是很重要的。尽管单例可以被实现成静态实例。但是同时也可以延迟构造，不需要消耗资源也不会消耗内存直到需要它的时候再初始化。&lt;/p&gt;
&lt;p&gt;如果我们有一个可以被直接初始化的静态对象，我们需要确保代码是按照顺序执行的。（比如，车的对象初始化的时候车轮必须已经存在）并且它在你有很多资源文件的时候不会变大。&lt;/p&gt;
&lt;p&gt;单例和静态对象都很有用，但是不能过度使用。就像不能过度使用其他模式一样。&lt;/p&gt;
&lt;p&gt;实践中，当我们在整个系统中只需要一个对象与其他对象通信的时候，单例模式是非常有用的。下面就是单例在上下文中使用模式的一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var SingletonTester = (function () {

  // options: an object containing configuration options for the singleton
  // e.g var options = { name: &amp;quot;test&amp;quot;, pointX: 5};
  function Singleton( options ) {

// set options to the options supplied
// or an empty object if none are provided
options = options || {};

// set some properties for our singleton
this.name = &amp;quot;SingletonTester&amp;quot;;

this.pointX = options.pointX || 6;

this.pointY = options.pointY || 10;

   }

   // our instance holder
  var instance;

  // an emulation of static variables and methods
  var _static = {

name: &amp;quot;SingletonTester&amp;quot;,

    // Method for getting an instance. It returns
    // a singleton instance of a singleton object
    getInstance: function( options ) {
      if( instance === undefined ) {
        instance = new Singleton( options );
      }

      return instance;

    }
  };

  return _static;

})();

var singletonTest = SingletonTester.getInstance({
      pointX: 5
});

// Log the output of pointX just to verify it is correct
// Outputs: 5
console.log( singletonTest.pointX );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;尽管单例在这里使用时有效的，但是经常当我们需要在javascript中使用它的时候，往往意味着我们应该重新审视我们的设计啦。&lt;/p&gt;
&lt;p&gt;他们往往意味着系统的模块要不就是耦合过紧啦，要么逻辑延伸的太大啦。单例的使用往往会让测试变得更加困难，因为存在隐藏依赖，难以创建多个实例，难以找到根依赖等问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript&quot; tar
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
      <category term="设计模式" scheme="http://wangfulin.github.io/categories/javascript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="javascript, 设计模式" scheme="http://wangfulin.github.io/tags/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt;设计模式：发布/订阅模式解析</title>
    <link href="http://wangfulin.github.io/2015/10/20/design-patterns-pub-sub-explained-in-js/"/>
    <id>http://wangfulin.github.io/2015/10/20/design-patterns-pub-sub-explained-in-js/</id>
    <published>2015-10-19T16:00:00.000Z</published>
    <updated>2016-04-28T07:58:10.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://abdulapopoola.com/2013/03/12/design-patterns-pub-sub-explained/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Design Patterns:PubSub Explained&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;这个模式用来作为中间人，一个把发布者和订阅者架接在一起的代理。发布者是当完成某些过程的时候触发事件的对象，订阅者是希望当发布者发布的时候希望被通知的对象。&lt;/p&gt;
&lt;p&gt;生活中有一个很好地例子，广播电台，人们会把频道调到他们最喜欢的节目。广播站不知道观众听得是什么或者他们正在听什么。他只需要发布他们的节目就可以啦。观众也不知道广播站制作节目的过程。他们只要在他们最喜欢的节目运行的时候把台调到对应的频道或者告知朋友就行。&lt;/p&gt;
&lt;p&gt;发布/订阅者模式实现了松耦合：你可以让发布者发布消息，订阅者接受消息而不是寻找一种方式把两个分离的系统连接在一起。&lt;/p&gt;
&lt;h2 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;松耦合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发布者不需要知道订阅者的数量，订阅者听得话题或者订阅者是通过什么方式运行的。他们能够相互独立地运行，这样就可以让你分开开发这两部分而不需要担心对状态或实现的任何细微的影响。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可扩展性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发布/订阅模式可以让系统在无论什么时候无法负载的时候扩展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更干净地设计&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;充分地利用好发布/订阅模式，你不得不深入地思考不同的组件是如何交互的。这通常会让我们有更干净地设计因为我们对解耦和松耦合的强调。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;灵活性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你不需要担心不同的组件是如何组合在一起的。只要他们共同遵守一份协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以很好地找出发布者或订阅者是否会得到错误的信息&lt;/p&gt;
&lt;h2 id=&quot;缺点&quot;&gt;&lt;a href=&quot;#缺点&quot; class=&quot;headerlink&quot; title=&quot;缺点&quot;&gt;&lt;/a&gt;缺点&lt;/h2&gt;&lt;p&gt;发布/订阅模式最大的有点是解耦，但同时也是最大的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;中间人也许不会通知系统消息传送的状态。所以我们无法知道消息传送是成功的还是失败的。紧耦合是需要保证这一点的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发布者不知道订阅者的状态，反之亦然，这样的话，你根本不知道在另一端是否会没有问题？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;随着订阅者和发布者数量的增加，不断增加的消息传送回导致架构的不稳定，容易在负载大的时候出问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;攻击者（恶意的发布者）能够入侵系统并且撕开它。这会导致恶意的消息被发布，订阅者能够获得他们以前并不能获得的消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更新发布者和订阅者的关系会是一个很难的问题，因为毕竟他们根本不认识对方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要中间人/代理商，消息规范和相关的规则会给系统增加一些复杂度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;p&gt;现实没有银弹，但是这个模式是设计松耦合系统的很好地方式。这和RSS,Atom和PubSubHubbub的思想一样。&lt;/p&gt;
&lt;p&gt;发布/订阅模式例子（Javascript）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var makePubSub=function(){
    var callbacks={},
    publish=function(){
        //Turn arguments object into real array
        var args=Array.prototype.slice.call(arguments,0);

        //Extract the event name which is the first entry
        var ev=args.shift();

        //Return if callbacks object doesn&amp;apos;t contain
        //any entry for event
        var list,i,l;
        if(!callbacks[ev]){
            return this;
        }
        list=callbacks[ev];

        //Invoke the callbacks,passing in the rest of parameters
        for(i=0,l=list.length;i&amp;lt;l;i++){
            list[i].apply(this,args);
        }

        return this;
    },
    subscribe=function(ev,callback){
        //Check if ev is already registered
        //If it isn&amp;apos;t create an array entry for it
        if(!callbacks[ev]){
            callbacks[ev]=[];
        }
        callbacks[ev].push(callback);
        return this;
    };

    return {pub:publish,sub:subscribe};
}

test=makePubSub();
test.sub(&amp;quot;alert&amp;quot;,function(){alert(&amp;quot;hell0&amp;quot;);})
test.pub(&amp;quot;alert&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://abdulapopoola.com/2013/03/12/design-patterns-pub-sub-explained/&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
      <category term="设计模式" scheme="http://wangfulin.github.io/categories/javascript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="javascript, 设计模式" scheme="http://wangfulin.github.io/tags/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt;用CSS来禁止文本选择</title>
    <link href="http://wangfulin.github.io/2015/09/20/disable-text-selection/"/>
    <id>http://wangfulin.github.io/2015/09/20/disable-text-selection/</id>
    <published>2015-09-19T16:00:00.000Z</published>
    <updated>2016-04-28T08:42:00.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://sixrevisions.com/css/disable-text-selection/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Disable Text Selection with CSS&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有些时候我们需要禁止网页的部分文本不能被选择。你可以使用&lt;code&gt;user-select&lt;/code&gt;这个CSS特性来实现这个需求。&lt;/p&gt;
&lt;h2 id=&quot;举例&quot;&gt;&lt;a href=&quot;#举例&quot; class=&quot;headerlink&quot; title=&quot;举例&quot;&gt;&lt;/a&gt;举例&lt;/h2&gt;&lt;p&gt;下面是一个使用了&lt;code&gt;disable-selection&lt;/code&gt;类的样式规则，当它作用于一个HTML元素的时候，它会让我们不能够选择这个元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.disable-selection{
    -moz-user-select:none; /* Firefox */
     -ms-user-select:none; /* Internet Explorer */
   -ktml-user-select:none; /* KHTML浏览器（比如：Konqueror） */
 -webkit-user-select:none; /* Chrome,Safari,and Opera */
   -webkit-touch-callout:none; /* Disable Android and IOS callout */
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于这些样式的一些细节的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-webkit-user-select&lt;/code&gt;是给Chrome,Safari和Opera用的（并不需要使用&lt;code&gt;-o-user-select&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;没有前缀的&lt;code&gt;user-select&lt;/code&gt;是被故意略去的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-webkit-touch-callout&lt;/code&gt;属性可以让在移动设备上的触摸后弹出失效。就像下面的这些，我们可以让它们不能出现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\disable-text-selection\disable-callout.jpg&quot; alt=&quot;disable-callout&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;演示&quot;&gt;&lt;a href=&quot;#演示&quot; class=&quot;headerlink&quot; title=&quot;演示&quot;&gt;&lt;/a&gt;演示&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\disable-text-selection\disable-text-selection.jpg&quot; alt=&quot;disable-selection&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cdn.sixrevisions.com/demos/disable-text-selection/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;查看演示&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;要时常记住的&quot;&gt;&lt;a href=&quot;#要时常记住的&quot; class=&quot;headerlink&quot; title=&quot;要时常记住的&quot;&gt;&lt;/a&gt;要时常记住的&lt;/h2&gt;&lt;p&gt;有一个陷阱就是：&lt;code&gt;user-select&lt;/code&gt;并不是W3C规范中标准的CSS特性。尽管&lt;code&gt;user-select&lt;/code&gt;通过添加浏览器前缀有很好的浏览器支持。&lt;/p&gt;
&lt;p&gt;前面的例子中，我没有使用没有前缀的&lt;code&gt;user-select&lt;/code&gt;特性声明。那是因为在web标准中根本就没有这个属性。我们可以对它的使用类比于于IE专有的CSS属性&lt;code&gt;ms-filter&lt;/code&gt;或者&lt;code&gt;-ms-text-kashida-space&lt;/code&gt;的属性的使用。&lt;/p&gt;
&lt;p&gt;其他需要注意的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;user-select&lt;/code&gt;是&lt;strong&gt;有问题并且是不稳定的&lt;/strong&gt;。有些时候你依然还是可以选择文本，特别是当你从没有被屏蔽掉文本选择的文本的那部分开始选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用全选快捷键有些时候还是会把屏蔽文本选择&lt;/strong&gt;(Win:Ctrl+A/Mac:Cmd+A)。这种情况你可以在IE11中清楚的了解到。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这不是一种万全的保证文本不被选择的策略。&lt;/strong&gt;CSS能够很容易被屏蔽。这种技巧依赖于非标准的CSS特性，这意味着未来对这个属性的可持续支持上面存在着很大的不确定性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;屏蔽掉文本选择是很恼人的。&lt;/strong&gt;我会在渐进提升的过程中使用这个技巧：只有当它可以提高使用支持这个&lt;code&gt;user-select&lt;/code&gt;特性的浏览器和设备的用户的用户体验的时候才使用它。但是，我绝不会把它设置成一个大范围的CSS选择器像全部选择器(*）或者&lt;code&gt;body&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这个&lt;code&gt;user-select&lt;/code&gt;特性可能会让你的样式表失效&lt;/strong&gt;。如果遵循标准对你来说非常重要，使用这个属性会在你使用规范测试比如说&lt;a href=&quot;https://jigsaw.w3.org/css-validator/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Validation Service&lt;/a&gt;的使用出现问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\disable-text-selection\user-select-validation.png&quot; alt=&quot;user-select-validation&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;浏览器支持&quot;&gt;&lt;a href=&quot;#浏览器支持&quot; class=&quot;headerlink&quot; title=&quot;浏览器支持&quot;&gt;&lt;/a&gt;浏览器支持&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;更新于：&lt;/strong&gt;2015年3月&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;浏览器&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;版本支持（以上）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Chrome&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Firefox&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;IE&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Safari&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;3.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;移动端&lt;br&gt;|浏览器|版本支持（以上）|&lt;br&gt;|:——|:—–|&lt;br&gt;|Chrome(Android)|2.1|&lt;br&gt;|Safari(IOS)|3.2|&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://sixrevisions.com/css/disable-text-selection/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Disable Tex
    
    </summary>
    
      <category term="CSS" scheme="http://wangfulin.github.io/categories/CSS/"/>
    
    
      <category term="css" scheme="http://wangfulin.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt;简单的用javascript实现的数据双向绑定</title>
    <link href="http://wangfulin.github.io/2015/08/20/easy-two-way-data-binding-in-javascript/"/>
    <id>http://wangfulin.github.io/2015/08/20/easy-two-way-data-binding-in-javascript/</id>
    <published>2015-08-19T16:00:00.000Z</published>
    <updated>2016-04-28T08:42:06.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://www.lucaongaro.eu/blog/2012/12/02/easy-two-way-data-binding-in-javascript/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Easy Two-Way Data Binding in Javascript&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;双向数据绑定指的是当对象的属性发生变化时能够同时改变对应的UI，反之亦然。换句话说，如果我们有一个&lt;code&gt;user&lt;/code&gt;对象，这个对象有一个&lt;code&gt;name&lt;/code&gt;属性，无论何时你对&lt;code&gt;user.name&lt;/code&gt;设置了一个新值，UI也会展示这个新的值。同样的，如果UI包含一个用于数据用户名字的输入框，输入一个新值也会导致&lt;code&gt;user&lt;/code&gt;对象的&lt;code&gt;name&lt;/code&gt;属性发生相应的改变。&lt;/p&gt;
&lt;p&gt;许多流行的javascript框架，像Ember.js,Angular.js或者KnockoutJS都会把双向数据绑定作为其中的主要特性来宣传。这并不意味着从头开始实现它很难，也不意味着当我们需要这种功能的时候，使用这些框架是我们唯一的选择。内部的潜在思想事实上是相当基础的，实现它可以归纳为以下三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们需要一种方式确定哪个UI元素绑定在哪个属性上。&lt;/li&gt;
&lt;li&gt;我们需要监控属性和UI的变化&lt;/li&gt;
&lt;li&gt;我们需要把所有绑定的对象和UI元素的变化传播出去。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;尽管有好多种方式去实现这几点，一种简单高效的方法是我们通过发布订阅者模式来实现。方法很简单：我们可以使用定制的&lt;code&gt;data&lt;/code&gt;属性作为HTML代码中需要绑定的属性。所有的绑定在一起的Javascript对象和DOM元素将会&lt;code&gt;订阅&lt;/code&gt;这个发布订阅对象。任何时候我们检测到无论是Javascript对象亦或是HTML的input元素的变化，我们都是把事件代理传递给发布订阅对象，然后通过它把所有发生在绑定的对象和元素的的变化传递和广播出去。&lt;/p&gt;
&lt;h2 id=&quot;一个用jQuery实现的简单例子&quot;&gt;&lt;a href=&quot;#一个用jQuery实现的简单例子&quot; class=&quot;headerlink&quot; title=&quot;一个用jQuery实现的简单例子&quot;&gt;&lt;/a&gt;一个用jQuery实现的简单例子&lt;/h2&gt;&lt;p&gt;通过jQuery实现我们上面讨论的东西是相当简单明了的，因为作为一个流行的库，它让我们很简单的实现订阅和发布DOM事件，同时我们也可以定制一个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function DataBinder(object_id){
    // Use a jQuery object as simple PubSub
    var pubSub=jQuery({});

    // We expect a `data` element specifying the binding
    // in the form:data-bind-&amp;lt;object_id&amp;gt;=&amp;quot;&amp;lt;property_name&amp;gt;&amp;quot;
    var data_attr=&amp;quot;bind-&amp;quot;+object_id,
        message=object_id+&amp;quot;:change&amp;quot;;

    // Listen to chagne events on elements with data-binding attribute and proxy
    // then to the PubSub, so that the change is &amp;quot;broadcasted&amp;quot; to all connected objects
    jQuery(document).on(&amp;quot;change&amp;quot;,&amp;quot;[data-]&amp;quot;+data_attr+&amp;quot;]&amp;quot;,function(eve){
        var $input=jQuery(this);

        pubSub.trigger(message,[$input.data(data_attr),$input.val()]);
    });

    // PubSub propagates chagnes to all bound elemetns,setting value of
    // input tags or HTML content of other tags
    pubSub.on(message,function(evt,prop_name,new_val){
        jQuery(&amp;quot;[data-&amp;quot;+data_attr+&amp;quot;=&amp;quot;+prop_name+&amp;quot;]&amp;quot;).each(function(){
            var $bound=jQuery(this);

            if($bound.is(&amp;quot;&amp;quot;)){
                $bound.val(new_val);
            }else{
                $bound.html(new_val);
            }
        });
    });
    return pubSub;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至于javascript对象，下面是最小化的&lt;code&gt;user&lt;/code&gt;数据模型实现的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function User(uid){
    var binder=new DataBinder(uid),

        user={
            attributes:{},
            // The attribute setter publish changes using the DataBinder PubSub
            set:function(attr_name,val){
                this.attributes[attr_name]=val;
                binder.trigger(uid+&amp;quot;:change&amp;quot;,[attr_name,val,this]);
            },

            get:function(attr_name){
                return this.attributes[attr_name];
            },

            _binder:binder
        };

    // Subscribe to PubSub
    binder.on(uid+&amp;quot;:change&amp;quot;,function(evt,attr_name,new_val,initiator){
        if(initiator!==user){
            user.set(attr_name,new_val);
        }
    });

    return user;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，无论何时我们想要绑定一个对象的属性到UI上，我们只要在对应的HTML元素上设置合适的&lt;code&gt;data&lt;/code&gt;属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// javascript 
var user=new User(123);
user.set(&amp;quot;name&amp;quot;,&amp;quot;Wolfgang&amp;quot;);

// html
&amp;lt;input type=&amp;quot;number&amp;quot; data-bind-123=&amp;quot;name&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;input输入框上值得变化会自动的映射到&lt;code&gt;user&lt;/code&gt;的&lt;code&gt;name&lt;/code&gt;属性，反之亦然。大功告成！&lt;/p&gt;
&lt;h2 id=&quot;不需要jQuery的实现方式&quot;&gt;&lt;a href=&quot;#不需要jQuery的实现方式&quot; class=&quot;headerlink&quot; title=&quot;不需要jQuery的实现方式&quot;&gt;&lt;/a&gt;不需要jQuery的实现方式&lt;/h2&gt;&lt;p&gt;现在的大部分项目一般jQuery都已经在使用啦，所以上面的例子是完全可以接受的。但是如果我们需要完全不依赖jQuery，那么该怎么实现呢？好吧，事实上其实也不难办到（特别是当我们把对IE的支持只提供IE8以上的支持）。最后，我们只是要通过发布订阅者模式来观察DOM事件而已。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function DataBinder( object_id ) {
  // Create a simple PubSub object
  var pubSub = {
    callbacks: {},

    on: function( msg, callback ) {
      this.callbacks[ msg ] = this.callbacks[ msg ] || [];
      this.callbacks[ msg ].push( callback );
    },

    publish: function( msg ) {
      this.callbacks[ msg ] = this.callbacks[ msg ] || []
      for ( var i = 0, len = this.callbacks[ msg ].length; i &amp;lt; len; i++ ) {
        this.callbacks[ msg ][ i ].apply( this, arguments );
      }
    }
  },

  data_attr = &amp;quot;data-bind-&amp;quot; + object_id,
  message = object_id + &amp;quot;:change&amp;quot;,

  changeHandler = function( evt ) {
    var target = evt.target || evt.srcElement, // IE8 compatibility
        prop_name = target.getAttribute( data_attr );

    if ( prop_name &amp;amp;&amp;amp; prop_name !== &amp;quot;&amp;quot; ) {
      pubSub.publish( message, prop_name, target.value );
    }
  };

 // Listen to change events and proxy to PubSub
  if ( document.addEventListener ) {
    document.addEventListener( &amp;quot;change&amp;quot;, changeHandler, false );
  } else {
    // IE8 uses attachEvent instead of addEventListener
    document.attachEvent( &amp;quot;onchange&amp;quot;, changeHandler );
  }

  // PubSub propagates changes to all bound elements
  pubSub.on( message, function( evt, prop_name, new_val ) {
var elements = document.querySelectorAll(&amp;quot;[&amp;quot; + data_attr + &amp;quot;=&amp;quot; + prop_name + &amp;quot;]&amp;quot;),
    tag_name;

for ( var i = 0, len = elements.length; i &amp;lt; len; i++ ) {
  tag_name = elements[ i ].tagName.toLowerCase();

  if ( tag_name === &amp;quot;input&amp;quot; || tag_name === &amp;quot;textarea&amp;quot; || tag_name === &amp;quot;select&amp;quot; ) {
    elements[ i ].value = new_val;
  } else {
    elements[ i ].innerHTML = new_val;
  }
}
  });

  return pubSub;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数据模型可以保持不变，除了在setter中对jQuery中&lt;code&gt;trigger&lt;/code&gt;方法的调用，我们可以通过我们在PubSub中自定义的&lt;code&gt;publish&lt;/code&gt;方法来代替。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// In the model&amp;apos;s setter:
function User( uid ) {
  // ...

  user = {
    // ...
    set: function( attr_name, val ) {
          this.attributes[ attr_name ] = val;
          // Use the `publish` method
          binder.publish( uid + &amp;quot;:change&amp;quot;, attr_name, val, this );
    }
  }

  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们又一次通过一百行不到，又可维护的纯javascript完成了我们想要的结果。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://www.lucaongaro.eu/blog/2012/12/02/easy-two-way-data-binding-in-javascript/&quot; target=&quot;_bla
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
      <category term="设计模式" scheme="http://wangfulin.github.io/categories/javascript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="javascript, 设计模式" scheme="http://wangfulin.github.io/tags/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt;jQuery事件绑定的最佳实践</title>
    <link href="http://wangfulin.github.io/2015/06/20/Effective%20Event%20Binding%20with%20jQuery/"/>
    <id>http://wangfulin.github.io/2015/06/20/Effective Event Binding with jQuery/</id>
    <published>2015-06-19T16:00:00.000Z</published>
    <updated>2016-04-28T08:42:12.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://www.sitepoint.com/effective-event-binding-jquery/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Effective Event Binding with jQuery&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你经常使用jQuery，那么你也许很熟悉事件绑定。这是很基本的东西，但是深入一点，你就能够找到机会让你事件驱动的代码变得不太零碎，并且更容易管理。&lt;/p&gt;
&lt;h2 id=&quot;更好的选择器策略&quot;&gt;&lt;a href=&quot;#更好的选择器策略&quot; class=&quot;headerlink&quot; title=&quot;更好的选择器策略&quot;&gt;&lt;/a&gt;更好的选择器策略&lt;/h2&gt;&lt;p&gt;让我们从基础的例子开始。下面的HTML代码表示的是可以开合的导航菜单。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button class=&amp;quot;nav-menu-toggle&amp;quot;&amp;gt;Toggle Nav Menu&amp;lt;/button&amp;gt;
&amp;lt;nav&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/&amp;quot;&amp;gt;West Philadelphia&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/cab&amp;quot;&amp;gt;Cab Whistling&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/throne&amp;quot;&amp;gt;Throne Sitting&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面这个是点击按钮之后控制导航菜单开合的javascript代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;apos;.nav-menu-toggle&amp;apos;).on(&amp;apos;click&amp;apos;,function(){
    $(&amp;apos;nav&amp;apos;).toggle();
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这可能是最常用的实现方式。它能够使用，但是比较脆。javascript代码依赖了按钮的类名&lt;code&gt;nav-menu-toggle&lt;/code&gt;。很可能在未来其他开发者或者健忘的你在重构代码的时候会删除或者重命名这个类名。&lt;/p&gt;
&lt;p&gt;问题的核心是我们同时在表现和交互中使用了CSS的类名。这违反了关注点分离的原则，让维护更容易出错。&lt;/p&gt;
&lt;p&gt;让我们用一个不同的方法来实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button data-hook=&amp;quot;nav-menu-toggle&amp;quot;&amp;gt;Toggle Nav Menu&amp;lt;/button&amp;gt;
&amp;lt;nav data-hook=&amp;quot;nav-menu&amp;quot;&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/&amp;quot;&amp;gt;West Philadelphia&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/cab&amp;quot;&amp;gt;Cab Whistling&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/throne&amp;quot;&amp;gt;Throne Sitting&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/nav&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这次我们使用这个data属性（data-hook）来选择元素。任何对CSS类的改变将不会影响到javascript，让我们能够实现关注点分离以及更加稳定的代码。&lt;/p&gt;
&lt;p&gt;下面我们用&lt;code&gt;data-hook&lt;/code&gt;属性来选择对应的元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;apos;[data-hook=&amp;quot;nav-menu-toggle&amp;quot;]&amp;apos;).on(&amp;apos;click&amp;apos;,function(){
    $(&amp;apos;[data-hook=&amp;quot;nav-menu&amp;quot;]&amp;apos;).toggle();
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，我也使用&lt;code&gt;data-hook&lt;/code&gt;作为&lt;code&gt;nav&lt;/code&gt;元素的选择器。你不一定需要，但是我喜欢这里面包含的思想：任何使用你看到&lt;code&gt;data-hook&lt;/code&gt;，你会知道这个元素在javascript中引用到啦。&lt;/p&gt;
&lt;h2 id=&quot;一些语法糖&quot;&gt;&lt;a href=&quot;#一些语法糖&quot; class=&quot;headerlink&quot; title=&quot;一些语法糖&quot;&gt;&lt;/a&gt;一些语法糖&lt;/h2&gt;&lt;p&gt;我必须承认&lt;code&gt;data-hook&lt;/code&gt;选择器并不是很漂亮。让我们通过扩展jQuery实现一个自定义的函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.extend({
    hook:function(hookName){
        var selector;
        if(!hookName || hookName === &amp;apos;*&amp;apos;){
            // select all data-hooks
            selector=&amp;apos;[data-hook]&amp;apos;
        }else{
            // select specific data-hook
            selector=&amp;apos;[data-hook*=&amp;quot;&amp;apos;+hookName+&amp;apos;&amp;quot;]&amp;apos;;
        }
        return $(selector);
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面准备完毕，我们来重写一下javascript。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.hook(&amp;apos;nav-menu-toggle&amp;apos;).on(&amp;apos;&amp;apos;,function(){
    $.hook(&amp;apos;nav-menu&amp;apos;).toggle();
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更好的是，我们甚至可以把一系列以空格分开的hook名字放在一个元素上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button data-hook=&amp;quot;nav-menu-toggle video-pause click-track&amp;quot;&amp;gt;Toggle Nav Menu&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以找到里面的任意个hook名字：&lt;br&gt;    $.hook(‘click-track’); // returns the button as expected&lt;/p&gt;
&lt;p&gt;我们也能够找到页面上所有的hook元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// both are equivalent
$.hook();
$.hook(&amp;apos;*&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;防止函数表达式&quot;&gt;&lt;a href=&quot;#防止函数表达式&quot; class=&quot;headerlink&quot; title=&quot;防止函数表达式&quot;&gt;&lt;/a&gt;防止函数表达式&lt;/h2&gt;&lt;p&gt;到目前为止，我们在事件处理中使用的都是匿名函数。让我们重写一下，使用声明的函数来代替它。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function toggleNavMenu(){
    $.hook(&amp;apos;nav-menu&amp;apos;).toggle();
}

$.hook(&amp;apos;nav-menu-toggle&amp;apos;).on(&amp;apos;click&amp;apos;,toggleNavMenu);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这让事件绑定的代码更加易读。这个&lt;code&gt;toggleNavMenu&lt;/code&gt;函数名表达了意图，是代码自我注释的好例子。&lt;/p&gt;
&lt;p&gt;我们同时也获得了可复用的能力，因为其他地方可能需要使用&lt;code&gt;toggleNavMenu&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;最后，这对于自动化测试来说是意见大喜事，因为声明的函数的单元测试要比匿名函数单元测试容易的多。&lt;/p&gt;
&lt;h2 id=&quot;同时使用多个事件&quot;&gt;&lt;a href=&quot;#同时使用多个事件&quot; class=&quot;headerlink&quot; title=&quot;同时使用多个事件&quot;&gt;&lt;/a&gt;同时使用多个事件&lt;/h2&gt;&lt;p&gt;jQuery提供了一个简单方便的语法来处理多事件的问题。比如，你可以为一系列空格隔开的事件列表绑定同一个事件处理函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.hook(&amp;apos;nav-menu-toggle&amp;apos;).on(&amp;apos;click keydown mouseenter&amp;apos;,trackAction);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你需要为不同的事件绑定不同的处理函数，你可以使用对象表达方式：&lt;br&gt;    $.hook(‘nav-menu-toggle’).on({&lt;br&gt;        ‘click’:trackClick,&lt;br&gt;        ‘keydown’:tranckKeyDown,&lt;br&gt;        ‘mouseenter’:trackMouseEnter&lt;br&gt;    });&lt;/p&gt;
&lt;p&gt;反过来，你可以同时取消多个事件的绑定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// unbinds keydown and mouseenter
$.hook(&amp;apos;nav-menu-toggle&amp;apos;).off(&amp;apos;keydown mouseenter&amp;apos;);

// nuclear options:unbinds everything
$.hook(&amp;apos;nav-menu-toggle&amp;apos;).off();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以想象到的是，不小心的取消事件绑定可能会导致严重的我们不想要的副作用。继续看我们可以通过哪些技巧来减轻这个问题。&lt;/p&gt;
&lt;h2 id=&quot;小心的取消事件绑定&quot;&gt;&lt;a href=&quot;#小心的取消事件绑定&quot; class=&quot;headerlink&quot; title=&quot;小心的取消事件绑定&quot;&gt;&lt;/a&gt;小心的取消事件绑定&lt;/h2&gt;&lt;p&gt;一般情况下我们不会在一个元素的同一事件类型绑定多个事件处理函数。让我们再看一下之前的那个按钮：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button data-hook=&amp;quot;nav-menu-toggle video-pause click-track&amp;quot;&amp;gt;Toggle Nav Menu&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不同的代码区域可能会在同一个元素的同一事件绑定不同的事件处理函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// somewhere in the nav code
$.hook(&amp;apos;nav-menu-toggle&amp;apos;).on(&amp;apos;click&amp;apos;,toggleNavMenu);

// somewhere in the video playback code
$.hook(&amp;apos;video-pause&amp;apos;).on(&amp;apos;click&amp;apos;,pauseCarltonDanceVideo);

// somewhere in the analytics code
$.hook(&amp;apos;click-track&amp;apos;).on(&amp;apos;click&amp;apos;,trackClick);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;尽管我们使用了不同的选择器，但是这个元素现在有三个事件处理函数啦。假如我们的分析代码不在关心这个按钮：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// no good
$.hook(&amp;apos;click-track&amp;apos;).off(&amp;apos;click&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;糟糕的是，上面的代码实际上回删除所有的点击事件处理函数，不仅仅是&lt;code&gt;trackClick&lt;/code&gt;。我们应该实用更加有辨别力的方式来指定我们需要删除的事件处理函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$.hook(&amp;apos;click-track&amp;apos;).off(&amp;apos;click&amp;apos;,trackClick);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一种方式是使用命名空间。任何事件都有资格使用一个命名空间来实现绑定和取消绑定，这样你就可以更好的控制事件绑定和取消绑定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// binds a click event in the &amp;quot;analytics&amp;quot; namespace
$.hook(&amp;apos;click-track&amp;apos;).on(&amp;apos;click.analytics&amp;apos;, trackClick);

// unbinds only click events in the &amp;quot;analytics&amp;quot; namespace
$.hook(&amp;apos;click-track&amp;apos;).off(&amp;apos;click.analytics&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你也可以使用多个命名空间：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// binds a click event in both the &amp;quot;analytics&amp;quot; and &amp;quot;usability&amp;quot; namespaces
$.hook(&amp;apos;click-track&amp;apos;).on(&amp;apos;click.analytics.usability&amp;apos;,trackClick);

// unbinds any events in either the &amp;quot;analytics&amp;quot; OR &amp;quot;usability&amp;quot; namespaces
$.hook(&amp;apos;click-track&amp;apos;).off(&amp;apos;.usability .analytics&amp;apos;);

// unbinds any events in both the &amp;quot;analytics&amp;quot; AND &amp;quot;usability&amp;quot; namespaces
$.hook(&amp;apos;click-track&amp;apos;).off(&amp;apos;.usability.analytics&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，命名空间的顺序是没有关系的，因为命名空间不是层级式的。&lt;/p&gt;
&lt;p&gt;如果你有一个复杂的功能需要多个元素绑定多个事件，那么使用命名空间是一种简单的把他们组织起来然后快速清除的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// free all elements on the page of any &amp;quot;analytics&amp;quot; event handling
$(&amp;apos;*&amp;apos;).off(&amp;apos;.analytics&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命名空间在写插件的时候尤其有用，因为这样你就能保证只会取消自己命名空间范围内的事件处理函数的绑定。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://www.sitepoint.com/effective-event-binding-jquery/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Effect
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
      <category term="jQuery" scheme="http://wangfulin.github.io/categories/javascript/jQuery/"/>
    
    
      <category term="javascript, jQuery" scheme="http://wangfulin.github.io/tags/javascript-jQuery/"/>
    
  </entry>
  
  <entry>
    <title>Web字体的初探</title>
    <link href="http://wangfulin.github.io/2015/05/20/Font/"/>
    <id>http://wangfulin.github.io/2015/05/20/Font/</id>
    <published>2015-05-19T16:00:00.000Z</published>
    <updated>2016-04-28T08:42:18.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;一，字体基本概念的介绍&quot;&gt;&lt;a href=&quot;#一，字体基本概念的介绍&quot; class=&quot;headerlink&quot; title=&quot;一，字体基本概念的介绍&quot;&gt;&lt;/a&gt;一，字体基本概念的介绍&lt;/h3&gt;&lt;h4 id=&quot;1-1-字体的分类&quot;&gt;&lt;a href=&quot;#1-1-字体的分类&quot; class=&quot;headerlink&quot; title=&quot;1.1 字体的分类&quot;&gt;&lt;/a&gt;1.1 字体的分类&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;1-1-1-Serif（衬线体）&quot;&gt;&lt;a href=&quot;#1-1-1-Serif（衬线体）&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 Serif（衬线体）&quot;&gt;&lt;/a&gt;1.1.1 Serif（衬线体）&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Serif（衬线）：在印刷的文字中衬线字体对于人眼的辨识更轻松，阅读更舒服横细竖粗，开始和结束的地方有装饰。在web上的字体，衬线字体比无衬线字体的辨识度更低，因为屏幕像素有限，不能很好地渲染出衬线体的效果。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;1-1-2-Sans-Serif（无衬线体&quot;&gt;&lt;a href=&quot;#1-1-2-Sans-Serif（无衬线体&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 Sans-Serif（无衬线体)&quot;&gt;&lt;/a&gt;1.1.2 Sans-Serif（无衬线体)&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Sans-Serif(无衬线体）：在印刷的文字中，无衬线体比较醒目，在小字体场合比衬线体更加清晰，但是辨识度没有衬线体高。在web字体中，无衬线字体比衬线字体更易读。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;1-1-3-Monospace（等宽字体）&quot;&gt;&lt;a href=&quot;#1-1-3-Monospace（等宽字体）&quot; class=&quot;headerlink&quot; title=&quot;1.1.3 Monospace（等宽字体）&quot;&gt;&lt;/a&gt;1.1.3 Monospace（等宽字体）&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Monospace（等宽字体）：每个宽度都一致的字体，看起来比较整齐，比较适合用于显示代码。比较著名的有Courier New字体。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;1-1-4-Cursive（草书）&quot;&gt;&lt;a href=&quot;#1-1-4-Cursive（草书）&quot; class=&quot;headerlink&quot; title=&quot;1.1.4 Cursive（草书）&quot;&gt;&lt;/a&gt;1.1.4 Cursive（草书）&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;Cursive（草书）：相当于印刷中的手写体，看起来比较流畅，像手写一样。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;1-2-常用的字体&quot;&gt;&lt;a href=&quot;#1-2-常用的字体&quot; class=&quot;headerlink&quot; title=&quot;1.2 常用的字体&quot;&gt;&lt;/a&gt;1.2 常用的字体&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;Serif，Sans-Serif，Monospace属于标准字体，Cursive,Fantasy属于非标准字体
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;1-2-1-衬线体（Serif）&quot;&gt;&lt;a href=&quot;#1-2-1-衬线体（Serif）&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 衬线体（Serif）&quot;&gt;&lt;/a&gt;1.2.1 衬线体（Serif）&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;常用的中文衬线体：宋体（Simsun），仿宋（FangSong），楷体（KaiTi），华文仿宋（STFangSong），华文楷体（STKaiTi）。
常见的英文衬线体：Times new Roman，Times
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;1-2-2-无衬线体（Sans-Serif）&quot;&gt;&lt;a href=&quot;#1-2-2-无衬线体（Sans-Serif）&quot; class=&quot;headerlink&quot; title=&quot;1.2.2 无衬线体（Sans-Serif）&quot;&gt;&lt;/a&gt;1.2.2 无衬线体（Sans-Serif）&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;常见的中文无衬线体：微软雅黑（Microsoft YaHei），黑体（SimHei），华文细黑（STXiHei）
常见的英文无衬线体：Tahoma，Arial，Helvetica，Verdana
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;1-2-3-等宽字体（monospace）&quot;&gt;&lt;a href=&quot;#1-2-3-等宽字体（monospace）&quot; class=&quot;headerlink&quot; title=&quot;1.2.3 等宽字体（monospace）&quot;&gt;&lt;/a&gt;1.2.3 等宽字体（monospace）&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;常见的等宽字体：Courier New，Courier
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;1-2-4-草书（Cursive）&quot;&gt;&lt;a href=&quot;#1-2-4-草书（Cursive）&quot; class=&quot;headerlink&quot; title=&quot;1.2.4 草书（Cursive）&quot;&gt;&lt;/a&gt;1.2.4 草书（Cursive）&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;常见的草书：Comic Sans MS
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;1-2-5-Fantasy&quot;&gt;&lt;a href=&quot;#1-2-5-Fantasy&quot; class=&quot;headerlink&quot; title=&quot;1.2.5 Fantasy&quot;&gt;&lt;/a&gt;1.2.5 Fantasy&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;常见的Fantasy：Impact
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;二，网站中使用的字体&quot;&gt;&lt;a href=&quot;#二，网站中使用的字体&quot; class=&quot;headerlink&quot; title=&quot;二，网站中使用的字体&quot;&gt;&lt;/a&gt;二，网站中使用的字体&lt;/h3&gt;&lt;h4 id=&quot;2-1-英文网站中使用的默认字体&quot;&gt;&lt;a href=&quot;#2-1-英文网站中使用的默认字体&quot; class=&quot;headerlink&quot; title=&quot;2.1 英文网站中使用的默认字体&quot;&gt;&lt;/a&gt;2.1 英文网站中使用的默认字体&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;font：12px/1.5 Tahoma,Helvetica,Arial,sans-serif
Tahoma：英文windows操作系统默认的字体
Helvetica：Mac OS X系统的系统默认字体
Arial：早期windows英文系统的默认字体。XP和Vista都是Tahoma
Sans-serif是针对linux的，linux默认只有kernel，字体由用户自定义。
无论是XP还是Vista下，不指定网页的中文字体时，默认的就是宋体。因此在font-family中使用”宋体“是多余的，可以省去。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-2-Windows操作系统提供的中文字体&quot;&gt;&lt;a href=&quot;#2-2-Windows操作系统提供的中文字体&quot; class=&quot;headerlink&quot; title=&quot;2.2 Windows操作系统提供的中文字体&quot;&gt;&lt;/a&gt;2.2 Windows操作系统提供的中文字体&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;黑体：SimHei
宋体：SimSun
新宋体：NSimSun
仿宋：FangSong
楷体：KaiTi
仿宋GB2312：FangSongGB2312
楷体GB2312：KaiTiGB2312
微软雅黑：Microsoft YaHei(Windows 7开始提供）
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-3-OS-X操作系统提供的中文字体&quot;&gt;&lt;a href=&quot;#2-3-OS-X操作系统提供的中文字体&quot; class=&quot;headerlink&quot; title=&quot;2.3 OS X操作系统提供的中文字体&quot;&gt;&lt;/a&gt;2.3 OS X操作系统提供的中文字体&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;冬青黑体：Hiragino Sans GB（Snow Leopard开始提供）
华文细黑：STHeiti Light（又名STXiHei）
华文黑体：STHeiTi
华文楷体：STKaiTi
华文宋体：STSong
华文仿宋：STFangsong
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-4-更多有趣的字体使用&quot;&gt;&lt;a href=&quot;#2-4-更多有趣的字体使用&quot; class=&quot;headerlink&quot; title=&quot;2.4 更多有趣的字体使用&quot;&gt;&lt;/a&gt;2.4 更多有趣的字体使用&lt;/h4&gt;&lt;p&gt;上面介绍的字体属于常见的字体，也就是我们所说的Web safe font。其在大部分网站是可以正常显示的。下面介绍的是比较有趣特殊的字体的使用方式。&lt;/p&gt;
&lt;h4 id=&quot;2-5-使用web-font的方法&quot;&gt;&lt;a href=&quot;#2-5-使用web-font的方法&quot; class=&quot;headerlink&quot; title=&quot;2.5 使用web font的方法&quot;&gt;&lt;/a&gt;2.5 使用web font的方法&lt;/h4&gt;&lt;h5 id=&quot;2-5-1-使用link标签&quot;&gt;&lt;a href=&quot;#2-5-1-使用link标签&quot; class=&quot;headerlink&quot; title=&quot;2.5.1 使用link标签&quot;&gt;&lt;/a&gt;2.5.1 使用link标签&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;通过link导入样式，然后直接通过font-family使用，如：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;&amp;lt;link href=&amp;#39;https://fonts.googleapis.com/css?family=Lobster&amp;#39; rel=&amp;#39;stylesheet&amp;#39; type=&amp;#39;text/css&amp;#39;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;font-family:&amp;quot;lobster&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.google.com/fonts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google Fonts&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;2-5-2-使用-import导入&quot;&gt;&lt;a href=&quot;#2-5-2-使用-import导入&quot; class=&quot;headerlink&quot; title=&quot;2.5.2 使用@import导入&quot;&gt;&lt;/a&gt;2.5.2 使用@import导入&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;通过@import导入字体的样式，如：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;@import url(https://fonts.googleapis.com/css?family=Candal);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;font-family:&amp;quot;Candal&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.google.com/fonts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google Fonts&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;2-5-3-使用javascript&quot;&gt;&lt;a href=&quot;#2-5-3-使用javascript&quot; class=&quot;headerlink&quot; title=&quot;2.5.3 使用javascript&quot;&gt;&lt;/a&gt;2.5.3 使用javascript&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;通过javascript获取字体样式，如：
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
     WebFontConfig = {
        google: { families: [ &amp;apos;Shadows+Into+Light::latin&amp;apos; ] }
    };
    (function() {
        var wf = document.createElement(&amp;apos;script&amp;apos;);
        wf.src = (&amp;apos;https:&amp;apos; == document.location.protocol ? &amp;apos;https&amp;apos; : &amp;apos;http&amp;apos;) +
              &amp;apos;://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js&amp;apos;;
        wf.type = &amp;apos;text/javascript&amp;apos;;
        wf.async = &amp;apos;true&amp;apos;;
        var s = document.getElementsByTagName(&amp;apos;script&amp;apos;)[0];
        s.parentNode.insertBefore(wf, s);
    })(); 
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;font-family:&amp;quot;Shadows Into Light&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.google.com/fonts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google Fonts&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;2-5-4-使用font-face&quot;&gt;&lt;a href=&quot;#2-5-4-使用font-face&quot; class=&quot;headerlink&quot; title=&quot;2.5.4 使用font-face&quot;&gt;&lt;/a&gt;2.5.4 使用font-face&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;首先需要从网站下载对应的字体，然后url填入文件路径，如：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;@font-face{
                font-family:&amp;quot;saucer&amp;quot;;
                src:url(&amp;quot;fonts/SaucerBB.ttf&amp;quot;) format(&amp;quot;truetype&amp;quot;);
            }&lt;/code&gt;&lt;br&gt;&lt;code&gt;font-family:saucer;&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;2-5-5-使用这些特殊字体的弊端&quot;&gt;&lt;a href=&quot;#2-5-5-使用这些特殊字体的弊端&quot; class=&quot;headerlink&quot; title=&quot;2.5.5 使用这些特殊字体的弊端&quot;&gt;&lt;/a&gt;2.5.5 使用这些特殊字体的弊端&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;使用这些特殊字体可以产生很炫酷的文字，但是也存在很大的弊端：
1，不同的环境显示的内容可能不一样
2，显示的内容不可靠
3，需要把字体包含到网站（有时可能有100kb大）中需要消耗大量的下载时间
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;三，大型网站上的字体实践&quot;&gt;&lt;a href=&quot;#三，大型网站上的字体实践&quot; class=&quot;headerlink&quot; title=&quot;三，大型网站上的字体实践&quot;&gt;&lt;/a&gt;三，大型网站上的字体实践&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1.淘宝：font-family: tahoma, arial, &amp;apos;Hiragino Sans GB&amp;apos;, 宋体, sans-serif;
2.百度：font-family: arial, 宋体, &amp;apos;Hiragino Sans GB&amp;apos;, &amp;apos;Microsoft Yahei&amp;apos;, 微软雅黑, 宋体, Tahoma, Arial, Helvetica, STHeiti;
3.京东：font-family: Arial, Verdana, 宋体；
4.Youtube：font-family: Roboto, arial, sans-serif;
5.github：font-family: Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, &amp;apos;Segoe UI Emoji&amp;apos;, &amp;apos;Segoe UI Symbol&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考的网站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.leafdigital.com/class/lessons/graphicdesign1/4.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;creating good websites&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kb.cnblogs.com/page/192018/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;serif和sans-serif的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/07/chinese_fonts.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中文字体网页开发指南&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一，字体基本概念的介绍&quot;&gt;&lt;a href=&quot;#一，字体基本概念的介绍&quot; class=&quot;headerlink&quot; title=&quot;一，字体基本概念的介绍&quot;&gt;&lt;/a&gt;一，字体基本概念的介绍&lt;/h3&gt;&lt;h4 id=&quot;1-1-字体的分类&quot;&gt;&lt;a href=&quot;#1-1-字体的分
    
    </summary>
    
      <category term="CSS" scheme="http://wangfulin.github.io/categories/CSS/"/>
    
      <category term="font" scheme="http://wangfulin.github.io/categories/CSS/font/"/>
    
    
      <category term="web, CSS" scheme="http://wangfulin.github.io/tags/web-CSS/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt; ES6 生成器基础</title>
    <link href="http://wangfulin.github.io/2015/05/04/The%20Basics%20Of%20ES6%20Generators/"/>
    <id>http://wangfulin.github.io/2015/05/04/The Basics Of ES6 Generators/</id>
    <published>2015-05-03T16:00:00.000Z</published>
    <updated>2016-04-28T08:00:47.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;原文:&lt;/strong&gt;&lt;a href=&quot;https://davidwalsh.name/es6-generators&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Basics Of ES6 Generators&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;原文:&lt;/strong&gt;&lt;a href=&quot;https://davidwalsh.name/es6-generators&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Basics Of ES6 Generators&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
      <category term="ES6" scheme="http://wangfulin.github.io/categories/javascript/ES6/"/>
    
    
      <category term="javascript, es6" scheme="http://wangfulin.github.io/tags/javascript-es6/"/>
    
  </entry>
  
  <entry>
    <title>出现次数最多的字符</title>
    <link href="http://wangfulin.github.io/2015/04/20/get-most-appearance-times/"/>
    <id>http://wangfulin.github.io/2015/04/20/get-most-appearance-times/</id>
    <published>2015-04-19T16:00:00.000Z</published>
    <updated>2016-04-28T08:42:22.000Z</updated>
    
    <content type="html">&lt;ol&gt;
&lt;li&gt;问题：给定一个字符串，求出里面出现次数最多的字符。&lt;/li&gt;
&lt;li&gt;输入：字符串&lt;/li&gt;
&lt;li&gt;输出：{[字符]:[出现次数],…}&lt;/li&gt;
&lt;li&gt;举例：输入：&lt;code&gt;&amp;#39;hello world&amp;#39;&lt;/code&gt;   输出：&lt;code&gt;{&amp;#39;l&amp;#39;:3}&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法1:&lt;/p&gt;
&lt;p&gt;先排序，然后单次遍历&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMostAppear&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;str&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(str.length === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sortedArr = str.split(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;).sort(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a, b&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a - b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; len = sortedArr.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 用来记录最多的次数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; max = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 用来记录出现最多次数的字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; c = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 用来记录当前字符和次数的映射&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; currAppear = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; len; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; currChar = sortedArr[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!currAppear[currChar])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			currAppear[currChar] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			currAppear[currChar]++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(currAppear[currChar] &amp;gt; max)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			max = currAppear[currChar];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			c = currChar;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mostAppear = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	mostAppear[c] = max;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mostAppear;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法2:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMostAppear&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;str&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(str.length === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; len = str.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 用来记录最多的次数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; max = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 用来记录出现最多次数的字符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; c = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 字符和出现次数的映射&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; charNumMap = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; len; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; curr = str.charAt(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!charNumMap[curr])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			charNumMap[curr] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			charNumMap[curr]++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(charNumMap[curr] &amp;gt; max)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			max = charNumMap[curr];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			c = curr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mostAppear = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	mostAppear[c] = max;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mostAppear;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;问题：给定一个字符串，求出里面出现次数最多的字符。&lt;/li&gt;
&lt;li&gt;输入：字符串&lt;/li&gt;
&lt;li&gt;输出：{[字符]:[出现次数],…}&lt;/li&gt;
&lt;li&gt;举例：输入：&lt;code&gt;&amp;#39;hello world&amp;#39;&lt;/code&gt;   输出：&lt;code&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
      <category term="面试题" scheme="http://wangfulin.github.io/categories/javascript/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="javascript" scheme="http://wangfulin.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>gulp的简介</title>
    <link href="http://wangfulin.github.io/2015/03/20/gulp/"/>
    <id>http://wangfulin.github.io/2015/03/20/gulp/</id>
    <published>2015-03-19T16:00:00.000Z</published>
    <updated>2016-04-28T08:42:26.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;什么是gulp&quot;&gt;&lt;a href=&quot;#什么是gulp&quot; class=&quot;headerlink&quot; title=&quot;什么是gulp&quot;&gt;&lt;/a&gt;什么是gulp&lt;/h2&gt;&lt;p&gt;gulp是在你的开发过程中用来帮你自动化一些麻烦耗时的工作的工具集。比如在web开发过程中，它能帮你完成css预处理，js文件整合，压缩，实时重加载等等。并且它还和目前市场上主流的IDE整合，无论是在PHP,.NET,Node.js,Java等等开发者都很喜欢用它。拥有超过1700中插件，gulp能够让你从繁琐的构建系统中解脱出来，真正的开始干活。&lt;/p&gt;
&lt;h2 id=&quot;怎样开始&quot;&gt;&lt;a href=&quot;#怎样开始&quot; class=&quot;headerlink&quot; title=&quot;怎样开始&quot;&gt;&lt;/a&gt;怎样开始&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装&lt;a href=&quot;http://www.infoq.com/cn/articles/nodejs-npm-install-config/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;创建一个项目，比如说gulptest&lt;/li&gt;
&lt;li&gt;在控制台项目路径下，npm init，跟着步骤创建package.json文件&lt;/li&gt;
&lt;li&gt;npm install –global gulp，使gulp命令可以在命令行中使用。&lt;/li&gt;
&lt;li&gt;npm install –save-dev gulp，在项目上安装gulp模块，同时将 gulp添加到package.json的dev-dependencies依赖中。&lt;/li&gt;
&lt;li&gt;比如我们需要压缩css文件，先安装需要的模块npm install –save-dev gulp-minify-css&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在项目路径下创建gulpfile.js&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var gulp = require(&amp;apos;gulp&amp;apos;);
var minifyCss = require(&amp;apos;gulp-minify-css&amp;apos;);

gulp.task(&amp;apos;minify-css&amp;apos;, function() {
  return gulp.src(&amp;apos;styles/*.css&amp;apos;)
    .pipe(minifyCss({compatibility: &amp;apos;ie8&amp;apos;}))
    .pipe(gulp.dest(&amp;apos;dist&amp;apos;));
   });
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行gulp minify-css命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;gulp-API&quot;&gt;&lt;a href=&quot;#gulp-API&quot; class=&quot;headerlink&quot; title=&quot;gulp API&quot;&gt;&lt;/a&gt;gulp API&lt;/h2&gt;&lt;p&gt;跳转到：&lt;a href=&quot;#gulpsrc&quot;&gt;gulp.src&lt;/a&gt; | &lt;a href=&quot;#gulpdest&quot;&gt;gulp.dest&lt;/a&gt; | &lt;a href=&quot;#gulptask&quot;&gt;gulp.task&lt;/a&gt; |&lt;a href=&quot;#gulpwatch&quot;&gt;gulp.watch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;gulpsrc&quot;&gt;gulp.src&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Emits files matching provided glob or an array of globs. Returns a stream of Vinyl files that can be piped to plugins.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.src(&amp;apos;client/templates/*.jade&amp;apos;)
      .pipe(jade())
     .pipe(minify())
      .pipe(gulp.dest(&amp;apos;build/minified_templates&amp;apos;));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据路径找到文件然后把它放在流里面pipe到gulp插件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.src(&amp;apos;client/js/**/*.js&amp;apos;) // Matches &amp;apos;client/js/somedir/somefile.js&amp;apos; and resolves `base` to `client/js/`
      .pipe(minify())
      .pipe(gulp.dest(&amp;apos;build&amp;apos;));  // Writes &amp;apos;build/somedir/somefile.js&amp;apos;

gulp.src(&amp;apos;client/js/**/*.js&amp;apos;, { base: &amp;apos;client&amp;apos; })
      .pipe(minify())
      .pipe(gulp.dest(&amp;apos;build&amp;apos;));  // Writes &amp;apos;build/js/somedir/somefile.js&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;gulpdest&quot;&gt;gulp.dest&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Can be piped to and it will write files. Re-emits all data passed to it so you can pipe to multiple folders. Folders that don’t exist will be created.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.src(&amp;apos;./client/templates/*.jade&amp;apos;)
      .pipe(jade())
      .pipe(gulp.dest(&amp;apos;./build/templates&amp;apos;))
     .pipe(minify())
      .pipe(gulp.dest(&amp;apos;./build/minified_templates&amp;apos;));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;gulptask&quot;&gt;gulp.task&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Define a task using &lt;a href=&quot;https://github.com/robrich/orchestrator&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Orchestrator&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;somename&amp;apos;, function() {
      // Do stuff
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An array of tasks to be executed and completed before your task will run.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;mytask&amp;apos;, [&amp;apos;array&amp;apos;, &amp;apos;of&amp;apos;, &amp;apos;task&amp;apos;, &amp;apos;names&amp;apos;], function() {
      // Do stuff
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You can also omit the function if you only want to run the dependency tasks:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;build&amp;apos;, [&amp;apos;array&amp;apos;, &amp;apos;of&amp;apos;, &amp;apos;task&amp;apos;, &amp;apos;names&amp;apos;]);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accept a callback&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// run a command in a shell
var exec = require(&amp;apos;child_process&amp;apos;).exec;
gulp.task(&amp;apos;jekyll&amp;apos;, function(cb) {
     // build Jekyll
     exec(&amp;apos;jekyll build&amp;apos;, function(err) {
       if (err) return cb(err); // return error
    cb(); // finished task
      });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Return a stream&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gulp.task(&amp;apos;somename&amp;apos;, function() {
     var stream = gulp.src(&amp;apos;client/**/*.js&amp;apos;)
        .pipe(minify())
        .pipe(gulp.dest(&amp;apos;build&amp;apos;));
      return stream;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Return a promise&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var Q = require(&amp;apos;q&amp;apos;);

gulp.task(&amp;apos;somename&amp;apos;, function() {
      var deferred = Q.defer();

      // do async stuff
      setTimeout(function() {
        deferred.resolve();
      }, 1);

      return deferred.promise;
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认情况下task中的任务是同步进行的，所以，如果需要在保证某一项任务在其他之前可以按照如下操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var gulp = require(&amp;apos;gulp&amp;apos;);

// takes in a callback so the engine knows when it&amp;apos;ll be done
gulp.task(&amp;apos;one&amp;apos;, function(cb) {
// do stuff -- async or otherwise
cb(err); // if err is not null and not undefined, the run will stop, and note that it failed
});

// identifies a dependent task must be complete before this one begins
gulp.task(&amp;apos;two&amp;apos;, [&amp;apos;one&amp;apos;], function() {
    // task &amp;apos;one&amp;apos; is done now
});

gulp.task(&amp;apos;default&amp;apos;, [&amp;apos;one&amp;apos;, &amp;apos;two&amp;apos;]);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;gulpwatch&quot;&gt;gulp.watch&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Watch files and do something when a file changes. This always returns an EventEmitter that emits change events.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Names of task(s) to run when a file changes, added with gulp.task()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var watcher = gulp.watch(&amp;apos;js/**/*.js&amp;apos;, [&amp;apos;uglify&amp;apos;,&amp;apos;reload&amp;apos;]);
watcher.on(&amp;apos;change&amp;apos;, function(event) {
      console.log(&amp;apos;File &amp;apos; + event.path + &amp;apos; was &amp;apos; + event.type + &amp;apos;, running tasks...&amp;apos;);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;常用的gulp-plugins&quot;&gt;&lt;a href=&quot;#常用的gulp-plugins&quot; class=&quot;headerlink&quot; title=&quot;常用的gulp plugins&quot;&gt;&lt;/a&gt;常用的gulp plugins&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;编译Sass &lt;a href=&quot;https://github.com/sindresorhus/gulp-ruby-sass&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-ruby-sass&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;自动添加前缀 &lt;a href=&quot;https://github.com/Metrime/gulp-autoprefixer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-autoprefixer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;压缩CSS &lt;a href=&quot;https://github.com/jonathanepollack/gulp-minify-css&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-minify-css&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JSHint &lt;a href=&quot;https://github.com/wearefractal/gulp-jshint&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-jshint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Concatenation &lt;a href=&quot;https://github.com/wearefractal/gulp-concat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-concat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Uglify &lt;a href=&quot;https://github.com/terinjokes/gulp-uglify&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-uglify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;图片压缩 &lt;a href=&quot;https://github.com/sindresorhus/gulp-imagemin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-imagemin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;实时重加载 &lt;a href=&quot;https://github.com/vohof/gulp-livereload&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-livereload&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;图片缓存从而只压缩改变的图片 &lt;a href=&quot;https://github.com/jgable/gulp-cache/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notify of changes &lt;a href=&quot;https://github.com/mikaelbr/gulp-notify&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-notify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;清除文件干净地构建 &lt;a href=&quot;https://www.npmjs.org/package/del&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;del&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;参考链接：&quot;&gt;&lt;a href=&quot;#参考链接：&quot; class=&quot;headerlink&quot; title=&quot;参考链接：&quot;&gt;&lt;/a&gt;参考链接：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gulpjs/gulp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github-gulp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gulpjs/gulp/blob/master/docs/README.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是gulp&quot;&gt;&lt;a href=&quot;#什么是gulp&quot; class=&quot;headerlink&quot; title=&quot;什么是gulp&quot;&gt;&lt;/a&gt;什么是gulp&lt;/h2&gt;&lt;p&gt;gulp是在你的开发过程中用来帮你自动化一些麻烦耗时的工作的工具集。比如在web开发过程中，它能帮你
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
      <category term="gulp" scheme="http://wangfulin.github.io/categories/javascript/gulp/"/>
    
    
      <category term="javascript, gulp" scheme="http://wangfulin.github.io/tags/javascript-gulp/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt;javascript的闭包是怎么工作的？</title>
    <link href="http://wangfulin.github.io/2015/02/20/how-do-javascript-closure-work/"/>
    <id>http://wangfulin.github.io/2015/02/20/how-do-javascript-closure-work/</id>
    <published>2015-02-19T16:00:00.000Z</published>
    <updated>2016-04-28T07:59:05.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://stackoverflow.com/questions/111102/how-do-javascript-closures-work&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;how to javascript closure work&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;http://stackoverflow.com/questions/111102/how-do-javascript-closures-work&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
    
      <category term="javascript, closure" scheme="http://wangfulin.github.io/tags/javascript-closure/"/>
    
  </entry>
  
  <entry>
    <title>Ajax 源码解析</title>
    <link href="http://wangfulin.github.io/2015/01/20/jquery-ajax-analyze/"/>
    <id>http://wangfulin.github.io/2015/01/20/jquery-ajax-analyze/</id>
    <published>2015-01-19T16:00:00.000Z</published>
    <updated>2016-04-28T07:59:13.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Ajax-是什么？&quot;&gt;&lt;a href=&quot;#Ajax-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Ajax 是什么？&quot;&gt;&lt;/a&gt;Ajax 是什么？&lt;/h2&gt;&lt;p&gt; 客户端用来创建异步 web 应用的技术集合。web 应用可以异步地向服务器发送数据或者获取内容。&lt;/p&gt;
&lt;h2 id=&quot;Ajax-做了什么？&quot;&gt;&lt;a href=&quot;#Ajax-做了什么？&quot; class=&quot;headerlink&quot; title=&quot;Ajax 做了什么？&quot;&gt;&lt;/a&gt;Ajax 做了什么？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提供了快捷的接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单性&lt;/li&gt;
&lt;li&gt;统一性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;屏蔽了浏览器差异性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;添加了默认的设置&lt;/li&gt;
&lt;li&gt;提供全局 Ajax 事件处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Ajax-部分的设计思路？&quot;&gt;&lt;a href=&quot;#Ajax-部分的设计思路？&quot; class=&quot;headerlink&quot; title=&quot;Ajax 部分的设计思路？&quot;&gt;&lt;/a&gt;Ajax 部分的设计思路？&lt;/h2&gt;&lt;h2 id=&quot;Ajax-核心源码解读&quot;&gt;&lt;a href=&quot;#Ajax-核心源码解读&quot; class=&quot;headerlink&quot; title=&quot;Ajax 核心源码解读&quot;&gt;&lt;/a&gt;Ajax 核心源码解读&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ajax-是什么？&quot;&gt;&lt;a href=&quot;#Ajax-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Ajax 是什么？&quot;&gt;&lt;/a&gt;Ajax 是什么？&lt;/h2&gt;&lt;p&gt; 客户端用来创建异步 web 应用的技术集合。web 应用可以异步地向服务器发送数据
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
      <category term="jQuery" scheme="http://wangfulin.github.io/categories/javascript/jQuery/"/>
    
      <category term="Ajax" scheme="http://wangfulin.github.io/categories/javascript/jQuery/Ajax/"/>
    
    
      <category term="javascript, jQuery, Ajax" scheme="http://wangfulin.github.io/tags/javascript-jQuery-Ajax/"/>
    
  </entry>
  
  <entry>
    <title>JS模块化初探</title>
    <link href="http://wangfulin.github.io/2014/12/20/JS_Module/"/>
    <id>http://wangfulin.github.io/2014/12/20/JS_Module/</id>
    <published>2014-12-19T16:00:00.000Z</published>
    <updated>2016-04-28T07:59:19.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;JS模块化初探&quot;&gt;&lt;a href=&quot;#JS模块化初探&quot; class=&quot;headerlink&quot; title=&quot;JS模块化初探&quot;&gt;&lt;/a&gt;JS模块化初探&lt;/h1&gt;&lt;h2 id=&quot;什么是JS模块化&quot;&gt;&lt;a href=&quot;#什么是JS模块化&quot; class=&quot;headerlink&quot; title=&quot;什么是JS模块化&quot;&gt;&lt;/a&gt;什么是JS模块化&lt;/h2&gt;&lt;h2 id=&quot;JS模块化有什么好处&quot;&gt;&lt;a href=&quot;#JS模块化有什么好处&quot; class=&quot;headerlink&quot; title=&quot;JS模块化有什么好处&quot;&gt;&lt;/a&gt;JS模块化有什么好处&lt;/h2&gt;&lt;h2 id=&quot;JS模块化实践&quot;&gt;&lt;a href=&quot;#JS模块化实践&quot; class=&quot;headerlink&quot; title=&quot;JS模块化实践&quot;&gt;&lt;/a&gt;JS模块化实践&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS模块化初探&quot;&gt;&lt;a href=&quot;#JS模块化初探&quot; class=&quot;headerlink&quot; title=&quot;JS模块化初探&quot;&gt;&lt;/a&gt;JS模块化初探&lt;/h1&gt;&lt;h2 id=&quot;什么是JS模块化&quot;&gt;&lt;a href=&quot;#什么是JS模块化&quot; class=&quot;headerli
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
      <category term="模块化" scheme="http://wangfulin.github.io/categories/javascript/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
      <category term="javascript, 模块化" scheme="http://wangfulin.github.io/tags/javascript-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt; Node.js 教程</title>
    <link href="http://wangfulin.github.io/2014/11/20/node-js-promise-generator-event/"/>
    <id>http://wangfulin.github.io/2014/11/20/node-js-promise-generator-event/</id>
    <published>2014-11-19T16:00:00.000Z</published>
    <updated>2016-04-28T08:44:45.000Z</updated>
    
    <content type="html">&lt;p&gt;[译]&lt;a href=&quot;http://www.guru99.com/node-js-promise-generator-event.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js Tutorial: Promise, Generator, Event and Filestream&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在前面的教程中，你已经看到了我们在异步事件中使用回调函数。但是有些时候当它们开始不断嵌套，并且程序变得越来越长越来越复杂的时候，回调函数就会像恶梦一般。&lt;/p&gt;
&lt;p&gt;在这些情况下，Node.js 提供了额外的特性来修复我们在使用回调的时候遇到的问题。这些特性被分成 Promise, generates 和 events. 这篇文章我们会更详细地学习和理解这些概念。&lt;/p&gt;
&lt;h2 id=&quot;什么是-promises&quot;&gt;&lt;a href=&quot;#什么是-promises&quot; class=&quot;headerlink&quot; title=&quot;什么是 promises&quot;&gt;&lt;/a&gt;什么是 promises&lt;/h2&gt;&lt;p&gt;在我们开始讲 promises 之前，让我们首先来回顾一下 Node.js 中 “callback” 是什么。我们在前面的章节中看到过很多，所以让我们快速地过一下其中的一个。&lt;/p&gt;
&lt;p&gt;下面的例子展示了一段代码片段，它被用来连接一个 MongoDB 的数据库，并且在数据库的一条记录中执行更新操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/callback.png&quot; alt=&quot;callback&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;上面的代码中，function(err,db) 这段代码被称作匿名函数的声明或者回调函数。当 MongoClient 创建了一个 MongoDB 数据库的连接时，一旦这个连接操作结束，它就会返回到回调函数执行。所以，某种意义上来说，连接操作在后台运行，并且当它结束之后，就会调用这个回调函数。记住这是之所以 Node.js 可以让很多操作同时发生但是不会阻塞用户执行操作的关键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二段代码片段就是回调函数被调用的时候真正执行的代码。这个回调函数就在 MongoDB 数据库中更新一条记录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么什么是 promise 呢？promise 就是 Node.js 中回调函数的一个改进。在开发的时候，我们可能遇到这样的场景，我们可能需要将多个回调函数嵌套起来。这种情况在一段时间后会变得有些杂乱和难以维护。简单的说，promise 就是来解决回调的这些问题的一个改进版。&lt;/p&gt;
&lt;p&gt;promise 的基本语法就像下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var promise = doSomethingAsync();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;promise.then(onFullfilled, onRejected);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;doSomethingAsync&lt;/code&gt;指的是任何执行某些异步操作回调或者匿名函数&lt;/li&gt;
&lt;li&gt;这一次，当定义回调的时候，有一个叫做&lt;code&gt;promise&lt;/code&gt;的值返回给我们&lt;/li&gt;
&lt;li&gt;当一个 promise 返回的时候，它有两个输出。这个由&lt;code&gt;then clause&lt;/code&gt;来定义。这个操作要么成功，这里通过&lt;code&gt;onFullfilled&lt;/code&gt;参数来表示，要么出错，这里通过&lt;code&gt;onRejected&lt;/code&gt;参数来表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 所以 promise 的关键是这个返回值。当我们在 Node.js 中处理正常的回调的时候，并没有返回值的概念。因为有了这个返回值，我们对回调函数有了更多的控制权。&lt;/p&gt;
&lt;h2 id=&quot;回调到-promise&quot;&gt;&lt;a href=&quot;#回调到-promise&quot; class=&quot;headerlink&quot; title=&quot;回调到 promise&quot;&gt;&lt;/a&gt;回调到 promise&lt;/h2&gt;&lt;p&gt;现在让我们看一个例子，看看我们在 Node.js 应用中是如何使用 &lt;code&gt;promises&lt;/code&gt; 的。为了能够在 Node.js 的应用程序中使用 &lt;code&gt;promise&lt;/code&gt; ,这个 &lt;code&gt;promise&lt;/code&gt; 模块首先需要下载和安装。&lt;/p&gt;
&lt;p&gt;接下来我们用 promises 来修改我们的代码，来更新 &lt;code&gt;Employee&lt;/code&gt; 集合中的 Employeename。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 npm 模块&lt;/p&gt;
&lt;p&gt;为了能够在 NodeJS 应用中使用 promise, 我们需要安装这个 promise 模块，运行下面的命令&lt;br&gt;npm install promise&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改代码来引入 promise&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/callback-to-promises.png&quot; alt=&quot;callback-to-promises&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一部分是包含这个&lt;code&gt;promise&lt;/code&gt;模块，让我们能够在代码中可以使用 promise 的功能。&lt;/li&gt;
&lt;li&gt;现在我们可以在 &lt;code&gt;MongoClient.connect&lt;/code&gt;函数后面添加&lt;code&gt;then&lt;/code&gt;函数啦。所以，这段代码的意思是当建立数据库连接之后，我们需要执行定义在&lt;code&gt;then&lt;/code&gt;里面的代码片段。&lt;/li&gt;
&lt;li&gt;最后，我们定义了执行更新操作的代码片段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你现在检查 MongoDB 数据库，你会发现如果&lt;code&gt;Martin&lt;/code&gt;雇员的名字存在，它会被更新成&lt;code&gt;Mohan&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果要检查是否在数据库中正确插入，你需要执行下面 MongoDB 的命令。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;use EmployeeDB&lt;/li&gt;
&lt;li&gt;db.Employee.find({EmployeeName:mohan})&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一个命令是保证你连上 &lt;code&gt;EmployeeDB&lt;/code&gt; 的数据库。第二个命令是查找名字为 &lt;code&gt;Mohan&lt;/code&gt; 的雇员的纪录&lt;/p&gt;
&lt;h2 id=&quot;处理嵌套的-promises&quot;&gt;&lt;a href=&quot;#处理嵌套的-promises&quot; class=&quot;headerlink&quot; title=&quot;处理嵌套的 promises&quot;&gt;&lt;/a&gt;处理嵌套的 promises&lt;/h2&gt;&lt;p&gt;当我们定义 promises 的时候，需要注意的是&lt;code&gt;then&lt;/code&gt;方法本身返回的也是一个 promise。所以，某种意义上来说 promises 可以嵌套或者链式调用。&lt;/p&gt;
&lt;p&gt;下面的例子中，我们使用链式调用来定义了两个回调函数。两个都向数据库插入了一条记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;链式调用是把一个方法的执行链接到另一个上的概念。假如你的应用有两个方法分别叫做&lt;code&gt;methodA&lt;/code&gt;和&lt;code&gt;methodB&lt;/code&gt;.并且逻辑是&lt;code&gt;methodB&lt;/code&gt;要在&lt;code&gt;methodA&lt;/code&gt;之后调用，这个时候你就可以把这种执行顺序通过在&lt;code&gt;methodA&lt;/code&gt;之后直接调用&lt;code&gt;methodB&lt;/code&gt;来链接起来。&lt;/p&gt;
&lt;p&gt;这个例子需要注意的关键是通过使用嵌套 promises 使得代码变得更简洁，可读和可维护了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/nested-promises.png&quot; alt=&quot;nested-promises&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们定义了两个&lt;code&gt;then&lt;/code&gt;语句来实现在一个执行完之后再执行另一个。第一个&lt;code&gt;then&lt;/code&gt;语句，我们将包含数据库连接的&lt;code&gt;db&lt;/code&gt;作为参数传递给它。接下来我们通过使用&lt;code&gt;db&lt;/code&gt;连接的属性&lt;code&gt;collection&lt;/code&gt;来插入一条记录。这个&lt;code&gt;insertOne&lt;/code&gt;方法被用来插入一个真正的文档对象给&lt;code&gt;Employee&lt;/code&gt;集合。&lt;/li&gt;
&lt;li&gt;接下来我们使用第二个&lt;code&gt;then&lt;/code&gt;语句来向数据库插入另一条记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你现在查看 MongoDB 数据库，你会在数据库中找到这两条记录。&lt;/p&gt;
&lt;h2 id=&quot;通过-BlueBird-库来生成-promises&quot;&gt;&lt;a href=&quot;#通过-BlueBird-库来生成-promises&quot; class=&quot;headerlink&quot; title=&quot;通过 BlueBird 库来生成 promises&quot;&gt;&lt;/a&gt;通过 &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BlueBird&lt;/a&gt; 库来生成 promises&lt;/h2&gt;&lt;p&gt;Bluebird 是一个功能完善的 promise 库。Bluebird 最重要的特性是它能够 &lt;code&gt;promisify&lt;/code&gt;其他&lt;code&gt;Node&lt;/code&gt;模块来异步地使用它们。Promisify 是一个应用在回调函数上的概念。这个概念用来保证每一个回调函数会返回一些值。&lt;/p&gt;
&lt;p&gt;所以，如果一个 NodeJS 模块包含了一个不返回任何值的回调函数，如果我们 &lt;code&gt;Promisify&lt;/code&gt;这个&lt;code&gt;node&lt;/code&gt;模块，那么所有在这个模块内部的函数都会被自动修改保证它有返回值。&lt;/p&gt;
&lt;p&gt;所以，你可以使用 Bluebird 让 MongoDB 模块异步运行。这样就从另一层面上提高了写 Node.js 应用程序的舒适性。&lt;/p&gt;
&lt;p&gt;我们接下来就看一个如果使用 bluebird 模块的例子。&lt;/p&gt;
&lt;p&gt;我们的例子首先建立一个到 &lt;code&gt;EmployeeDB&lt;/code&gt; 数据库中 &lt;code&gt;Employee collection&lt;/code&gt;的一个连接。如果接下来连接建立好了，它就会获取所有的集合中的记录并且在控制台中打印出来。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 npm 模块&lt;/p&gt;
&lt;p&gt; 要在 Node 应用程序中使用 Bluebird，必须包含这个模块，运行下面的命令：&lt;br&gt; npm install bluebird&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接下来就是包含这个 bluebird 模块，然后 promise 化整个 MongoDB 模块。这里的 promise 化，我们的意思是 bluebird 确保每一个定义在 MongoDB 类库中的方法都会返回一个 promise。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/bluebird.png&quot; alt=&quot;bluebird&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;require&lt;/code&gt;命令是用来包含这个 Bluebird 库的。&lt;/li&gt;
&lt;li&gt;通过使用 Bluebird 的 &lt;code&gt;promisifyAll()&lt;/code&gt;这个方法来创建 MongoDB 模块中每一个方法的异步版本。这确保每一个 MongoDB 模块的方法都会在后台中运行，并且确保 MongoDB 库的每一个方法都会返回一个   promise。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;最后一步就是连接数据库，获取集合中的所有记录然后在控制台展示它们。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/bluebird2.png&quot; alt=&quot;bluebird2&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你会发现我们这里使用&lt;code&gt;connectAsync&lt;/code&gt;方法而不是正常的&lt;code&gt;connect&lt;/code&gt;方法来连接数据库。Bluebird 是通过给每一个方法添加 Async 关键字来区分返回 promise 和不返回 promise 的调用。所以我们并不能保证没有 Async 关键字的方法会有返回值。&lt;/li&gt;
&lt;li&gt;和&lt;code&gt;connectAsync&lt;/code&gt;类似，我们现在使用&lt;code&gt;findAsync&lt;/code&gt;方法来返回所有在 MongoDB 数据库中 &lt;code&gt;Employee&lt;/code&gt;集合中的记录。&lt;/li&gt;
&lt;li&gt;最后，如果这个 &lt;code&gt;findAsync&lt;/code&gt;方法成功返回一个 promise ，我们接下来就可以定义一段代码来遍历集合中的每一个记录然后把它们的内容打印出来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果上面的步骤正确的执行，所有在&lt;code&gt;Employee&lt;/code&gt;集合的文档都会被打印到控制台，就像下面这样.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/bluebird3.png&quot; alt=&quot;bluebird3&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建一个自定义的-promise&quot;&gt;&lt;a href=&quot;#创建一个自定义的-promise&quot; class=&quot;headerlink&quot; title=&quot;创建一个自定义的 promise&quot;&gt;&lt;/a&gt;创建一个自定义的 promise&lt;/h2&gt;&lt;p&gt;一个自定义promise可以通过一个叫做&lt;code&gt;q&lt;/code&gt;的 node 模块来创建。这个&lt;code&gt;q&lt;/code&gt;模块需要通过 node 包管理工具来下载和安装。在使用&lt;code&gt;q&lt;/code&gt;这个库之后，这个&lt;code&gt;denodeify&lt;/code&gt;方法被调用之后会让任何函数变成一个会返回 promise 的函数。&lt;/p&gt;
&lt;p&gt;下面的例子中，我们首先创建一个简单的函数叫做&lt;code&gt;Add&lt;/code&gt;，它会把两个数加起来。我们要让这个函数转化为一个返回 promise 对象的函数.&lt;/p&gt;
&lt;p&gt;一旦转化成功之后，我们就会通过这个&lt;code&gt;Add&lt;/code&gt;函数返回的 promise 来在控制台中展示信息&lt;/p&gt;
&lt;p&gt;接下来让我们按照下面的方法来创建一个自定义的返回 promise 对象的方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 npm 模块&lt;/p&gt;
&lt;p&gt; 要使用&lt;code&gt;q&lt;/code&gt;这个模块，我们需要在 NodeJs 应用程序中包含它。安装这个&lt;code&gt;q&lt;/code&gt;模块，我们可以运行下面的命令&lt;br&gt; npm install q&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义下面的代码来创建自定义的 promise&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/q.png&quot; alt=&quot;q&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一段的作用是通过&lt;code&gt;require&lt;/code&gt;关键字包含这个&lt;code&gt;q&lt;/code&gt;库，通过使用这个库，我们就能够定义任何函数来返回一个回调函数。&lt;/li&gt;
&lt;li&gt;我们创建了一个叫做 Add 的函数，它会把两个有变量&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;表示的数字加起来，结果保存在&lt;code&gt;c&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;我们使用&lt;code&gt;q&lt;/code&gt;库来&lt;code&gt;denodeify&lt;/code&gt;（用来将任何函数转化成能够返回 promise 的函数的方法）我们的&lt;code&gt;Add&lt;/code&gt;函数。&lt;/li&gt;
&lt;li&gt;现在我们调用这个&lt;code&gt;Add&lt;/code&gt;函数就能够返回一个 promise ，因为我们之前&lt;code&gt;denodeify&lt;/code&gt;了这个&lt;code&gt;Add&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;这里的&lt;code&gt;then&lt;/code&gt;关键词被用来表示当函数成功执行之后在控制台中展示&lt;code&gt;Addition function completed&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当上面的代码执行之后，就会在控制台输出下面的内容&lt;br&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/q1.png&quot; alt=&quot;q1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是-generators&quot;&gt;&lt;a href=&quot;#什么是-generators&quot; class=&quot;headerlink&quot; title=&quot;什么是 generators&quot;&gt;&lt;/a&gt;什么是 generators&lt;/h2&gt;&lt;p&gt;generators 最近在 Node.js 中变得相当有名，这也许和它们能够做的事情有关。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Generators 是一个能够让函数执行挂起，并且在后面的某个时间点恢复&lt;/li&gt;
&lt;li&gt;Generators 在实现比如说&lt;code&gt;懒执行&lt;/code&gt;的概念的时候非常有用。这基本意味着通过挂起操作和随心所欲地恢复执行，我们能够只有在我们需要的时候取数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Generators 有下面两个关键字:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Yield 方法：这个&lt;code&gt;yield&lt;/code&gt;方法是在要在停止函数执行的时候调用的，函数就在&lt;code&gt;yield&lt;/code&gt;方法被调用的那一行停止。&lt;/li&gt;
&lt;li&gt;Next 方法：这个&lt;code&gt;next&lt;/code&gt;方法从主应用调用去恢复拥有&lt;code&gt;yield&lt;/code&gt;方法的函数的执行。这个函数会一直执行到遇到下一个&lt;code&gt;yield&lt;/code&gt;方法或者直到函数的结束.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们看一下下面的例子看看 generators 是怎么使用的。&lt;/p&gt;
&lt;p&gt;下面的例子中，我们会有一个把两个数字相加的&lt;code&gt;Add&lt;/code&gt;函数，但是但是我们会在函数中不同的地方停止函数的执行来展示 generators 是如何使用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/generators.png&quot; alt=&quot;generators&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步是定义我们的 generator 函数。注意这里是通过在 function 关键字后面添加&lt;code&gt;*&lt;/code&gt;完成的。接下来我们定义一个叫做&lt;code&gt;Add&lt;/code&gt; 的函数，接受一个&lt;code&gt;x&lt;/code&gt;作为参数.&lt;/li&gt;
&lt;li&gt;这个&lt;code&gt;yield&lt;/code&gt;关键字只用在 generators 中。这让它拥有能够在函数的人和位置暂停的能力。所以在这里，这个函数会一直停止，知道我们调用&lt;code&gt;next()&lt;/code&gt;函数，在第4步会调用。在这里，&lt;code&gt;x&lt;/code&gt;的值会变成6并且函数的执行会停止。&lt;/li&gt;
&lt;li&gt;这里就是我们调用 generator 函数并且把 5 作为参数传给这个函数的地方。&lt;/li&gt;
&lt;li&gt;一旦我们调用&lt;code&gt;next()&lt;/code&gt;方法，&lt;code&gt;Add()&lt;/code&gt;函数会恢复执行。当我们执行到下面这一个语句&lt;code&gt;var y = yield(null)&lt;/code&gt;的时候又会停止执行。(此时返回的 value 是 6,而不是上面说的 null)&lt;/li&gt;
&lt;li&gt;再次调用&lt;code&gt;next()&lt;/code&gt;方法，一只执行到&lt;code&gt;return x + y;&lt;/code&gt;结束。（此时返回的 value 是 null,而不是上面说的 11）。&lt;/li&gt;
&lt;li&gt;再次调用&lt;code&gt;next()&lt;/code&gt;方法，会直接返回 11.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;回调-VS-generators&quot;&gt;&lt;a href=&quot;#回调-VS-generators&quot; class=&quot;headerlink&quot; title=&quot;回调 VS generators&quot;&gt;&lt;/a&gt;回调 VS generators&lt;/h2&gt;&lt;p&gt; Generators 被用来解决一个叫做回调hell的问题。有些时候在 Node.js 应用中，回调函数嵌套的如此之深以至于它变得太复杂而不能使用回调。&lt;/p&gt;
&lt;p&gt; 这个时候 Generators 就派上用场啦。一个最常用的例子就是创建定时器函数。&lt;/p&gt;
&lt;p&gt; 让我们看看下面的例子来看看 generators 是如何证明它比回调更有用的。&lt;/p&gt;
&lt;p&gt; 我们的例子只创建一个简单的时间延迟函数。我们接下来会在 1s,2s,3s之后调用这个函数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个回调函数有必要的时间延迟的代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/callbackVsGenerators.png&quot; alt=&quot;callbacksVsGenerators&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里我们创建了一个叫做&lt;code&gt;Timedelay&lt;/code&gt;的函数，里面包含一个叫做 ptime 的参数，这个可以让我们等待给定的时间来执行回调&lt;/li&gt;
&lt;li&gt;下一步就是创建一条消息，告诉用户说这个应用程序会暂停这么多时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;现在我们来看一下如果我们包含很多回调的代码。假如我们想要在每次调用之后都增加 1s 再调用回调函数，下面的代码就是我们需要的用来实现的回调代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/callbackVsGenerators1.png&quot; alt=&quot;callbacksVsGenerators1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们以 1000 作为参数调用 Timedelay 函数&lt;/li&gt;
&lt;li&gt;接下来，我们以 2000 作为参数调用 Timedelay 函数&lt;/li&gt;
&lt;li&gt;最后，我们以 3000 作为参数调用 Timedelay 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;现在我们来看看如何通过 generators 来实现上面一样的功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://wangfulin.github.io/imgs\node-js-promise-generator-event/callbackVsGenerators2.png&quot; alt=&quot;callbacksVsGenerators2&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;[译]&lt;a href=&quot;http://www.guru99.com/node-js-promise-generator-event.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js Tutorial: Promise, Generat
    
    </summary>
    
      <category term="Node.js" scheme="http://wangfulin.github.io/categories/Node-js/"/>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/Node-js/javascript/"/>
    
    
      <category term="javascript, Node.js" scheme="http://wangfulin.github.io/tags/javascript-Node-js/"/>
    
  </entry>
  
  <entry>
    <title>npm常用命令解析</title>
    <link href="http://wangfulin.github.io/2014/10/20/npm/"/>
    <id>http://wangfulin.github.io/2014/10/20/npm/</id>
    <published>2014-10-19T16:00:00.000Z</published>
    <updated>2016-04-28T08:44:24.000Z</updated>
    
    <content type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;npm install&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm install &amp;lt; packagename &amp;gt;,比如npm install jquery&lt;/p&gt;
&lt;p&gt;npm install &amp;lt; packagename &amp;gt;@&amp;lt; version &amp;gt;,比如npm install jquery@2.1.3&lt;/p&gt;
&lt;p&gt;npm install &amp;lt; packagename &amp;gt;@&amp;lt; version-range &amp;gt;,比如 npm install jquery@”&amp;gt;=1.0.1 &amp;lt;3.0.0”&lt;/p&gt;
&lt;p&gt;npm install &amp;lt; packagename &amp;gt;@&amp;lt; tagname&amp;gt;,比如npm install jquery@latest&lt;/p&gt;
&lt;p&gt;npm install git地址,比如 npm install git@github.com:jquery/jquery&lt;/p&gt;
&lt;p&gt;npm install还可以加一些参数比如-g,–save,–save-dev，分别表示全局安装，将依赖添加到package.json的dependencies，添加到devDependencies。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;npm remove &lt;package-name&gt;&lt;/package-name&gt;&lt;/li&gt;
&lt;li&gt;npm update &lt;package-name&gt;&lt;/package-name&gt;&lt;/li&gt;
&lt;li&gt;npm config&lt;ul&gt;
&lt;li&gt;npm config set，比如npm config set registry &lt;a href=&quot;http://registry.cnpmjs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://registry.cnpmjs.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;npm config get，比如npm config get registry&lt;/li&gt;
&lt;li&gt;npm config list&lt;/li&gt;
&lt;li&gt;npm config ls -l,显示所有的默认设置&lt;/li&gt;
&lt;li&gt;npm config edit，更改配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;npm init，可以通过命令行来初始化package.json文件&lt;/li&gt;
&lt;li&gt;npm list，显示所有安装的包&lt;ul&gt;
&lt;li&gt;npm list -g 全局安装的模块&lt;/li&gt;
&lt;li&gt;npm list -g –depth=0 不显示模块的依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;npm root 查看当前包的安装路径&lt;/li&gt;
&lt;li&gt;npm root -g 查看全局包的安装入境&lt;/li&gt;
&lt;li&gt;npm [packagename] help,获取帮助&lt;/li&gt;
&lt;li&gt;npm outdated，查看所有过时的包&lt;/li&gt;
&lt;li&gt;npm prune，移除不再依赖的包&lt;/li&gt;
&lt;li&gt;npm search,查找相应的包&lt;/li&gt;
&lt;li&gt;npm cache clean,删除cache,即npm config get cache这个文件夹存的缓存。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;npm install&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm install &amp;lt; packagename &amp;gt;,比如npm install jquery&lt;/p&gt;
&lt;p&gt;npm install &amp;lt; packagename &amp;gt;@
    
    </summary>
    
      <category term="Node.js" scheme="http://wangfulin.github.io/categories/Node-js/"/>
    
      <category term="npm" scheme="http://wangfulin.github.io/categories/Node-js/npm/"/>
    
    
      <category term="npm, Node.js" scheme="http://wangfulin.github.io/tags/npm-Node-js/"/>
    
  </entry>
  
  <entry>
    <title>&lt;译&gt; React的双向绑定</title>
    <link href="http://wangfulin.github.io/2014/09/20/react-advanced-two-way-bind/"/>
    <id>http://wangfulin.github.io/2014/09/20/react-advanced-two-way-bind/</id>
    <published>2014-09-19T16:00:00.000Z</published>
    <updated>2016-04-28T08:00:24.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;https://www.terlici.com/2015/02/23/react-advanced-two-way-binding.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Advanced Two Way Binding for React&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://reactjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React&lt;/a&gt;是一个很好的库，它能够让开发web应用变得更简单。&lt;/p&gt;
&lt;p&gt;但是，从&lt;a href=&quot;https://angularjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Angular&lt;/a&gt;转过来的开发者第一眼看到的就是默认是不支持双向绑定的。这也是一些开发者不想尝试它的原因。&lt;/p&gt;
&lt;p&gt;尽管双向绑定是一个很cool的特性，但是事实上它并不是大部分应用需要的。然后，它有些时候也是很有用的。&lt;/p&gt;
&lt;p&gt;今天，我会向你展示一个我几乎每天都会用到的现实应用实例，没有数据的双向绑定，开发这个应用就会像噩梦一般。&lt;/p&gt;
&lt;p&gt;to be continuing&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原文：&lt;/strong&gt;&lt;a href=&quot;https://www.terlici.com/2015/02/23/react-advanced-two-way-binding.html&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
      <category term="javascript" scheme="http://wangfulin.github.io/categories/javascript/"/>
    
      <category term="React" scheme="http://wangfulin.github.io/categories/javascript/React/"/>
    
    
      <category term="javascript, React" scheme="http://wangfulin.github.io/tags/javascript-React/"/>
    
  </entry>
  
</feed>
