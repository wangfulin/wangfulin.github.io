{"meta":{"title":"wangfulin's blog","subtitle":"Day day up","description":"Live to learn","author":"wangfulin","url":"http://wangfulin.github.io"},"pages":[{"title":"About","date":"2016-04-28T06:25:39.000Z","updated":"2016-04-28T03:18:14.000Z","comments":true,"path":"about/index.html","permalink":"http://wangfulin.github.io/about/index.html","excerpt":"","keywords":null,"text":"The blog theme you may fall in love with, coming to Hexo. Preview InstallationInstall1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus Icarus requires Hexo 3.0 and above. Enable Rename themes\\icarus\\_config.yml.example to themes\\icarus\\_config.yml; Copy themes\\icarus\\_config.yml.site.example to your hexo blog’s root directory and rename it to _config.yml; Copy themes\\icarus\\_source\\* into your hexo blog’s directory source; Then modify theme setting in _config.yml to icarus. Update12cd themes/icarusgit pull ConfigurationTheme configuration example1234567891011121314151617181920212223242526272829303132333435363738394041# Headermenu: Home: . Archives: archives Categories: categories # you need to add extra page to enable this, please see the config below. Tags: tags # you need to add extra page to enable this, please see the config below. About: about# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- recent_posts- category- tag- tagcloud- archivethumbnail: true# Contactscontacts: github: http://github.com/ppoffice/hexo-theme-icarus twitter: '#' facebook: '#' dribbble: '#' rss: atom.xml# Linkslinks: Hexo: http://hexo.io# Miscellaneousgoogle_analytics:favicon: favicon.pngtwitter:google_plus:fb_admins:fb_app_id: excerpt_link - Cooperate with &lt;!-- more --&gt; tag to show only part of the article in index pages. fancybox - Enable Fancybox. contacts - Your social network links, RSS link, etc. widgets - Widgets displaying in sidebar. thumbnail - Whether to show post thumbnails in the sidebar and archive pages. links - Links displayed in the link widget. google_analytics - Google Analytics ID. favicon - Favicon path. Site configuration example123456789101112131415# Sitetitle: Icarussubtitle:description: Hexo theme - Icarusauthor: PPOfficeauthor_title: 'Web Developer &amp; Designer'avatar: css/images/avatar.pnglocation: 'Harbin, China'language: entimezone:...# Disqusdisqus_shortname: author - Your name. author_title - Title to your occupation. avatar - Your avatar image link. location - Where you live in. disqus_shortname - Your Disqus shortname. Post Thumbnail &amp; BannerYou can add a thumbnail and a banner to each post by adding the following lines into your post source files’ front-matter:123456title: Demodate: 2015-01-01...# add thosethumbnail: http://example.com/thumbnail.jpgbanner: http://example.com/banner.jpg Custom Categories &amp; Tags PagesTo enable custom categories page and tags page, just copy the categories folder and tags folder under your theme’s _source foler into your site’s source folder. Then edit theme’s _config.yml and add the following lines:123456# Headermenu: ... Categories: categories # -&gt; add this line Tags: tags # -&gt; and add this line ... LanguagesEnglish and Simplified Chinese are the default languages of the theme. You can add translations in the languages folder and change the default language in blog’s _config.yml. 1language: zh-CN FeaturesProfile SidebarA nice place to show yourself. You can add your own information in your site’s _config.yml Post Banner &amp; ThumbnailThanks to atika, you can now add thumbnails and banners to every post to create better reading experience. Responsive LayoutIcarus knows on what screen size you are browsering the website, and reorganize the layout to fit your device. Custom Categories &amp; Tags PagesGet your categories and tags listed in single pages to make your blog more methodic. FancyboxIcarus uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 1![img caption](img url) SidebarIcarus provides 6 built-in widgets: recent_posts category archives tag tagcloud links All of them are enabled by default. You can edit them in widget setting. DevelopmentRequirements Grunt 0.4+ Hexo 3.0+ Grunt tasks default - Download Fancybox and Font Awesome. fontawesome - Only download Font Awesome. fancybox - Only download Fancybox. clean - Clean temporarily files and downloaded files.","raw":null,"content":null},{"title":"Categories","date":"2016-04-28T06:25:39.000Z","updated":"2016-04-28T03:18:14.000Z","comments":true,"path":"categories/index.html","permalink":"http://wangfulin.github.io/categories/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"Tags","date":"2016-04-28T06:25:39.000Z","updated":"2016-04-28T03:18:14.000Z","comments":true,"path":"tags/index.html","permalink":"http://wangfulin.github.io/tags/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null}],"posts":[{"title":"45个javascript技巧和最佳实践","slug":"45-useful-javascript-tips-tricks-and-best-practices","date":"2016-03-23T16:00:00.000Z","updated":"2016-04-28T07:57:07.000Z","comments":true,"path":"2016/03/24/45-useful-javascript-tips-tricks-and-best-practices/","link":"","permalink":"http://wangfulin.github.io/2016/03/24/45-useful-javascript-tips-tricks-and-best-practices/","excerpt":"","keywords":null,"text":"原文：45 Useful Javascript Tips,Tricks and Best Practices 你知道的，Javascript是世界上第一的变成语言。它能够在web端，移动混合应用（像PhoneGap和Appcelerator），以及服务端（NodeJS和Wakanda）等其他地方都有应用。它也经常被用来当做很多世界上新的开发者的入门语言。它既能让我们在网页上展示弹窗，也能用来控制机器人。能够使用写出有组织，性能良好的javascript","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/tags/javascript/"}]},{"title":"browserify简介","slug":"broswerify","date":"2016-02-23T16:00:00.000Z","updated":"2016-04-28T07:57:28.000Z","comments":true,"path":"2016/02/24/broswerify/","link":"","permalink":"http://wangfulin.github.io/2016/02/24/broswerify/","excerpt":"","keywords":null,"text":"在浏览器中使用require(&#39;modules&#39;) 使用node的风格来组织浏览器端的代码并且可以加载通过npm安装的模块。 browerify将递归分析你应用中所有的require()调用去构建一个能够通过单个&lt;script&gt;标签引用的js文件。 如何开始 安装 npm install -g browserify 创建modules 创建foo.js module.exports=function(n){return n*111;} 创建bar.js module.exports=function(s){return s+&quot;!&quot;;} 创建main.js入口文件 var foo=require(&quot;foo.js&quot;); var bar=require(&quot;bar.js&quot;); var str=foo(100)+bar(&quot;bar&quot;); console.log(str); 使用browerify命令预编译main.js browserify main.js &gt; bundle.js 参考链接： node-browerify browserify-handbook","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"}],"tags":[{"name":"javascript, browserify","slug":"javascript-browserify","permalink":"http://wangfulin.github.io/tags/javascript-browserify/"}]},{"title":"<译>用CSS剪切圆形图片","slug":"circular-image-with-css","date":"2016-01-23T16:00:00.000Z","updated":"2016-04-28T07:57:35.000Z","comments":true,"path":"2016/01/24/circular-image-with-css/","link":"","permalink":"http://wangfulin.github.io/2016/01/24/circular-image-with-css/","excerpt":"","keywords":null,"text":"在这个教程，我们会介绍一下使用CSS技巧来渲染出圆形的元素，主要来实现这个效果的CSS属性是border-radius. 尽管对于正方形的图片来实现圆形这个效果是相当简单的，但是对于长方形来说可能需要多一点点工作。 正方形图片一个百分百正方形的img标签要变成圆形的只需要一行CSS代码。这个技巧在正方形图片上使用的最方便。 HTML &lt;img class=&quot;circle--square&quot; src=&quot;woman.png&quot; /&gt; CSS .circular--squareP{ border-radius:50%; } 通过设置img标签的所有的border-radius属性为正方形宽/高的50%，我们就可以把这个img标签变成圆的。 长方形图片长方形图片会稍微有一点技巧一点。 去渲染一个圆形，必须以圆形图片为基础 要解决这个问题，我们可以通过在img标签外面套一层div，然后我们通过将超过这个外层div的img标签的内容给裁掉来实现。具体的话可以通过将外层div的overflow属性设置为hidden。 为了能够让照片的主题不要被裁掉，我们必须要区别对待水平和垂直方向的图片。 水平方向的图片HTML &lt;div&gt; &lt;img src=&quot;images/brack-obama.png&quot; /&gt; &lt;/div&gt; CSS .circular--landscape{ display:inline-block; position:relative; width:200px; height:200px; overflow:hidden; border-radius:50%; } .circular--landscape img{ width:auto; height:100%; margin-left:-50%; } 高度和宽度属性必须要保持一样来确保这个div（.circular–landscape）能够作为正方形渲染起来 除此之外，高度和宽度属性必须要等于或者小于img的高度。这能够确保img元素能够占满外层div而不会多出一部分空白 一般来说，水平方向图片的主题（但不一定）会位于图片的中心位置。为了能够让我们尽量不会把图片的主题裁剪啦，我们可以通过把图片往左移来弥补图片剪切的内容有点偏右的问题。 我们移动img标签的大小是外层div的25%，在这个例子中就是向左50px，我们可以通过设置margin-left的属性来完成设置 margin-left:-50px; 图片的主题会接近图片的水平方向中心的假设并不一定是对的，最好在你选择使用这个技巧的使用把这个假设记住。 垂直方向的图片HTML &lt;div&gt; &lt;img src=&quot;images/woman-portrait.png&quot; /&gt; &lt;/div&gt; CSS .circular--portrait{ position:relative; width:200px; height:200px; overflow:hidden; border-radius:50%; } .circular--portrait img{ width:100%; height:auto; } 对于垂直方向上的图片的主题在垂直方向的中心的假设当然也不适用于每一个垂直方向上的图片。 和水平方向的图片类似，外层div的宽度和高度最好等于垂直方向图片你的宽度，这样的话可以产生最好的效果。 对于垂直方向的图片，我们把宽度设置为100%，高度设置为auto（和水平方向的图片相反） 我们不需要移动这个img元素，因为这张照片的主题就在上方中心位置。 回顾这个技巧最好适用于正方形的img标签，主题正好位于图片的中心。但是，我们的世界并不是那么完美的，所有如果需求是这样，我们就可以使用div来把长方形img标签变圆。 CSS中用来负责把图片变圆的属性是border-radius，把边的圆角变成高度/宽度的50%就可以产生一个圆。 原文链接：circular-images-css","raw":null,"content":null,"categories":[{"name":"CSS","slug":"CSS","permalink":"http://wangfulin.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wangfulin.github.io/tags/CSS/"}]},{"title":"<译>深入了解CSS Box Shadow","slug":"css-box-shadow","date":"2015-12-23T16:00:00.000Z","updated":"2016-04-28T07:57:42.000Z","comments":true,"path":"2015/12/24/css-box-shadow/","link":"","permalink":"http://wangfulin.github.io/2015/12/24/css-box-shadow/","excerpt":"","keywords":null,"text":"原文：A Close Look at CSS Box Shadow CSS的box-shadow可以被用来给块级元素一个外阴影或者是内阴影。接下来让我们仔细地看一下这个CSS的特性吧。 举例下面有三个把CSS的box-shadow属性使用在div里的例子。 ### 例１：简单的外阴影 下面是是给副标题添加阴影的样式。 box-shadow:0 0 10px gray; 例2：内阴影一个内阴影可以通过使用inset属性值来渲染出来。 box-shadow:inset 0 0 10px; 例3：偏移外阴影这个例子中我们通过水平和垂直方向下和右偏移5px来实现阴影向右下方偏移 box-shadow:5px 5px 10px; 加入你想要阴影向左上方偏移呢？我们可以通过将水平和垂直方向的偏移量设置为-5px，正如下面的例子： box-shadow:-5px -5px 10px; 既然你已经看到了box-shadow在现实中的使用，接下来让我们更加深入地了解一下。 语法box-shadow的一般语法如下： box-shadow:[inset] [horizontal offset] [vertical offset] [blur radius] [spread distance] [color] CSS属性值CSS的box-shadow可能会有6个属性值： inset horizontal offset vertical offset blur radius spread distance color 只有两个属性是必须的：水平偏移和垂直偏移量。 四个属性值，水平偏移，垂直偏移，模糊半径，扩展距离，必须使用CSS长度单元（比如：px,em,%等） 这个颜色值必须是必须是一个颜色单元，比如十六进制值（如：#000000）。 属性和值总结表 属性 是否必须 单位 默认值 inset 不是 关键词 没有指定的时候，阴影默认在外面 水平偏移 是 长度 没有默认值，一定有指定 垂直偏移 是 长度 没有默认值，一定要指定 模糊半径 不是 长度 0 扩展距离 不是 长度 0 颜色 不是 颜色 和box shadow属性作用的元素的color值一样 inset如果inset关键词存在，盒阴影将会放在HTML元素的内部 box-shadow:inset 0 0 5px 5px olive; 作为对比，这里是一个没有inset属性的box-shadow样式。 box-shadow:0 0 5px 5px olive; 水平偏移水平偏移控制了盒子阴影在x轴的偏移。正值会把盒子的阴影向右移动，负值的话会把它向左移动。 下面的例子中，我们把水平的偏移设置成20px，刚好是水平偏移量的两倍，所以阴影水平宽度刚好是垂直高度的两倍。 box-shadow:20px 10px; 垂直偏移垂直偏移控制了盒阴影在y轴的偏移量。正值会把盒子的阴影向下移动，负值刚好相反会把盒子网上移动。 下面的例子中，垂直的偏移设置成-20px，刚好是水平偏移的两倍。同时，因为是负值，所以向上移动。 box-shadow:10px -20px; 模糊半径这个模糊半径会影响到阴影的模糊和锐利程度。 模糊半径是可选的，如果你不指定它，默认值是0.另外，你不能指定它为负值，这个和水平偏移和垂直偏移不一样。 如果模糊半径是0，盒子阴影会很锐利并且它的颜色是很实的。随着你不断的增大这个值，它会变得越来越模糊和透明。 下面的例子，模糊半径被设置成20px，因此模糊度是相当突出。 box-shadow:5px 5px 20px; 扩展距离这个扩展距离会让盒子的阴影在各个方向上都会变大或变小。如果它有一个正值，盒子阴影会在各个方向上增加大小。如果是负值，则会在各个方向上收缩。 值得注意的是，因为它的扩展距离是正5，所以会在各个方向上增加10px因为没有水平和垂直偏移。 box-shadow:0 0 10px 5px; 当扩展距离是负的时候，阴影就会在各个方向上收缩。下面的例子展示当阴影的宽度比盒子小的时候的情况 box-shadow:0 10px 10px -5px; ### 颜色 通过名字你就可以判断出来，颜色值会设置盒阴影的颜色。它可以通过任何可以表示颜色的方式来表示颜色。是否设置颜色值是可选的。 换句话说，默认情况下当你没有指明颜色值，阴影颜色会等于这个盒子对应的html元素的颜色值。比如有一个div的颜色被设置成红色，这个盒子阴影的颜色也会变成红色： color:red; box-shadow:0 0 10px 5px; 如果你想要设置阴影的颜色和div的颜色不一样，可以通过下面的方式，你会发现尽管你的文字颜色是红色，盒子阴影颜色依然可以是蓝色。 color:red; box-shadow:0 0 10px 5px blue; 多阴影效果这个就是能够让我们变得有创造力的CSS属性。你能够在一个盒子上设置多个阴影。 语法就像下面这样。 box-shadow: [box shadow properties 1], [box shadow properties 2], [box shadow properties n]; 换句话说，你可以通过在每个属性设置组后面添加逗号(,)来实现多阴影。 下面的例子展示了两个阴影的情况，左上方红色的阴影，右下方蓝色的阴影。 box-shadow: -5px -5px 30px 5px red, 5px 5px 30px 5px blue; 浏览器支持这个CSS的box-shadow属性有着很好地浏览器支持。使用这个属性在拖后腿的IE浏览器也能在IE9以后得到支持啦。 查看演示","raw":null,"content":null,"categories":[{"name":"CSS","slug":"CSS","permalink":"http://wangfulin.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wangfulin.github.io/tags/CSS/"}]},{"title":"<译>聊一聊CSS方法论","slug":"css-methodologies","date":"2015-11-19T16:00:00.000Z","updated":"2016-04-28T07:57:49.000Z","comments":true,"path":"2015/11/20/css-methodologies/","link":"","permalink":"http://wangfulin.github.io/2015/11/20/css-methodologies/","excerpt":"","keywords":null,"text":"原文链接：A Look at Some CSS methodologies CSS在大型，复杂，快速迭代的系统中难以管理的程度是出了名的。 其中一个原因是CSS缺少内置的作用域管理机制。在CSS中，所有的一切都是全局的，这意味着任何你所做的改变都有可能层叠或者改变完全没有相关的那部分UI。 扩展的CSS语言，也称作CSS预处理器，比如说Sass，Less和Stylus，通过增加一些新的特性让写CSS代码变得更简单一点。但是就算有这些扩展性的CSS语言，在我看来，也并没有解决可扩展性问题。 在CSS没有自己的作用域机制之前，我们不得不设计出自己的一套系统来防止HTML文档的特定区域不被收到影响。 下面是关于CSS方法论的介绍可能让我们找到一些答案。 在这篇文章中，我们来看看这些CSS方法论： 面向对象的CSS（Object-Oriented CSS(OOCSS)） 块，元素，修饰符（Block,Element,Modifier(BEM)） 可扩展性和模块化性CSS架构（Scalable and Modular Architecture for CSS(SMACSS)） SUIT CSS 系统化CSS（Systematic CSS） CSS方法论是正式的，文档化写CSS的方法系统，它能够让我们以一系列小的，独立的方式来开发，维护和扩展前端代码。而不是作为一大块整体的不可分割的代码。 采用一种CSS方法论，甚至是你自己创建的一种，无论项目的大小和复杂度都会让CSS变得更好设计并且更好地在设计项目中迭代。 相关：大型网站的CSS开发 每一种CSS方法论都提供了一系列略微不同的解决CSS可扩展性/可维护性的方法。一个CSS方法论通常会定义一些指南： CSS和HTML最佳实践 Class和ID命名规范 CSS样式规则的排序和组合 代码格式 世界上并没有“最佳”的CSS方法论。不同的方法适应于不同的个人/项目组/项目。 我们希望的是，通过了解目前已经存在的CSS方法论可以帮助我们找到一种适应我们需求的方法。或者它也许能激发你的创造力，让你创建一个你自己专属的CSS方法论。 面向对象的CSS（OOCSS） Nicole Sullivan的面向对象的CSS，或者简单来说OOCSS，在2009年发布。 这实际上是第一个大范围采用的CSS方法论。甚至到现在也有很大的影响力。 OOCSS鼓励结构和样式的分离。这个方法论在内容和容器之间有着明显的区分。 在OOCSS中，样式规则只由CSS类选择器来写。 OOCSS例子比如你的button元素的样式可能有两个CSS类来设置，比如下面这两个 .button – 提供button的基本结构 .grey-btn – 提供颜色和其他视觉样式 CSS .button{ box-sizing:border-box; height:50px; width:100%; } .grey-btn{ background:#EEE; border:1px solid #DDD; box-shadow:rgba(0,0,0,0.5) 1px 1px 3px; color:#555; } HTML &lt;button class=&quot;button grey-btn&quot;&gt;&lt;/button&gt; 反例/* 后代选择器在OOCSS中是不被提倡的 */ .wrapper .blog-post .button{ ... } 通过这种方式，HTML元素的样式表现就不会依赖于其所在的特定DOM结构上，也就不会受到位置的影响。 OOCSS方法论这样做的最大好处就是它能够让作者最大的利用CSS层叠的样式的好处，而不是把它锁在高度具体的选择器中。 相关：CSS特性是怎么工作的？ 作者鼓励我们无论何时都去复用已有的样式而不是创建新的样式。我们也被鼓励通过新的类来扩展样式而不是修改或者覆盖已有的CSS样式。 反例HTML &lt;!-- 反例 --&gt; &lt;ul class=&quot;to-do&quot;&gt; &lt;li&gt;Combine my CSS files&lt;/li&gt; &lt;li&gt;Run CSS Lint&lt;/li&gt; &lt;li&gt;Minify my stylesheet&lt;/li&gt; &lt;/ul&gt; CSS /* 反例 */ .to-do{ color:#FFF; background-color:#000; } .to-do li:first-child{ color:#FF0000; } OOCSS例子 为了让我们的CSS更具模块化和灵活度，并且防止出现后代选择器，我们用下面的方式来复写上面的反例： HTML &lt;!-- OOCSS --&gt; &lt;ul class=&quot;to-do&quot;&gt; &lt;li class=&quot;first-to-do- item&quot;&gt;Combine my CSS files&lt;/li&gt; &lt;li&gt;Run CSS Lint&lt;/li&gt; &lt;li&gt;Minify my stylesheet&lt;/li&gt; &lt;/ul&gt; CSS /* OOCSS */ .to-do { color: #FFF; background-color: #000; } .first-to-do-item { color: #FF0000; } OOCSS的弱点是你很可能会使用很多很多的类，到最后你都无法维护或管理啦。 并且，在我看来，让OOCSS产生灵感的面向对象编程的思想在CSS中并不契合。 但是，这并不是说OOCSS的原则是无效的。相反，OOCSS是把大型CSS开发带来理性的常用的CSS方法论. 块，元素，修饰符 块，元素，修饰符－－更常被叫做BEM–是一个由被称为俄罗斯的谷歌的Yandex开发组开发的一套CSS体系。 在BEM背后的思想是区分实现不同角色的CSS类。这是通过把CSS命名为表示其角色的类名。 BEM刚好可以作为OOCSS的补充，因为OOCSS并没有施加任何的命名规范。 在BEM的方法论中，一个块是一个独立的模块好的UI组件。一个块可以由多个HTML元素组成，甚至有几个块组合而成。比如说导航菜单和搜索表单就是一个块的例子。 一个元素就是块的一个组件。一个元素一般用来完成一个目的。比如说，你有一个导航菜单块，那导航菜单的链接就是元素，它可以使一个列表项(li元素)或者链接(a元素). 一个修饰符是用来改变块或者元素默认样式的CSS类。 喜爱案就是BEM类命名的语法： .block .block–modifier .block__element .block__element–modifier 反例考虑下面的例子，标记代表的是一个登录表单： HTML &lt;form&gt; &lt;label&gt; username &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;/label&gt; &lt;label&gt; password &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;/label&gt; &lt;button&gt; Sign in &lt;/button&gt; &lt;/form&gt; BEM范例下面是使用BEM命名规则来为上面的标记命名： HTML &lt;form class=&quot;loginform loginform--errors&quot;&gt; &lt;label class=&quot;loginform__username loginform__username--error&quot;&gt; Username &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;/label&gt; &lt;label class=&quot;loginform__password&quot;&gt; Password &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;/label&gt; &lt;button class=&quot;loginform__btn loginform__btn--inactive&quot;&gt; Sign in &lt;/button&gt; &lt;/form&gt; 这个.loginform类是一个块。这个.loginform块由三个元素组成： 元素 作用 loginform__username 代表用户名 loginform__password 代表密码 loginform__btn 用户点击提交表单 这三个修饰符分别是： 修饰符 描述 .loginform__username–errror 错误时的样式 .loginform__btn–inactive 未激活样式 .loginform–errors 包含错误的样式 这种BEM的命名规则帮助CSS的作者遵循OOCSS的原则。通过使用这种扁平的命名方式避免了多后代的选择器。 反例所以我们不会用下面这种样式命名规则。。。 CSS .loginform .username .error{ ... } BEM范例。。。你只需要一个类选择器： CSS .loginform__username--error{ ... } BEM是一个非常鲁棒的命名规范。 它成功地区分了类的不同关注点。并且通过类名我们可以很简单的看到标记之间的关系。 一些关于BEM的主观批评如下： 类名会变的很长很难看 命名规范对于没有经验的开发者来说不是那么的好理解 作为个人来讲，我倒不认为这是特别强烈的批评。但是如果有一个能够和BEM一样鲁棒的命名规范同时能够更简洁和好理解那就更好啦。 待续。。。","raw":null,"content":null,"categories":[{"name":"CSS","slug":"CSS","permalink":"http://wangfulin.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://wangfulin.github.io/tags/CSS/"}]},{"title":"<译> 单例模式","slug":"Singleton-Pattern","date":"2015-11-09T16:00:00.000Z","updated":"2016-04-28T08:00:39.000Z","comments":true,"path":"2015/11/10/Singleton-Pattern/","link":"","permalink":"http://wangfulin.github.io/2015/11/10/Singleton-Pattern/","excerpt":"","keywords":null,"text":"原文：The Single Pattern 单例模式被熟知是因为它把一个类的实例化限制在只有一个对象。传统的实现方式是：创建一个类，这个类里面有一个方法在对象不存在的时候创造一个实例，存在的时候，只需要返回这个对象的引用即可。 单例和静态类（或者对象）是有区别的，因为我们可以延迟他们的初始化。因为他们需要一些在初始化的时候不能获得的信息。他们没有提供一种方式让不知道他们之前引用的代码去获取他们。这是因为由单例返回的既不是对象也不是类，而是一种结构。想想大括号形成的不是真正的闭包，函数作用于提供的闭包才是真正的闭包。 Javascript中，单例作为共享资源的命名空间，它隔离了实现的代码和全局变量，为了能够让函数有唯一的一个入口。 我们可以通过下面的方法实现单例： var mySingleton=(function(){ //存储单例引用的实例 var instance; function init(){ //单例 //私有方法和属性 function privateMethod(){ console.log(&quot;I am private); } var privateVariable=&quot;I&apos;m alse private&quot;; var privateRandomNumber=Math.random(); return { //公有方法和属性 publicMethod:function(){ console.log(&quot;The public can see me!); }, publicProperty:&quot;I am also public&quot;, getRandomNumber:function(){ return privateRandomNumber; } }; } return { //如果存在获取单例实例的引用 //不存在，创建实例 getInstance:function(){ if(!instance){ instance=init(); } return instance; } }; })(); var myBadSingleton=(function(){ //指向单例的引用 var instance; function init(){ //单例 var privateRandomNumber=Math.random(); return { getRandomNumber:function(){ return privateRandomNumber; } } } return { //无论什么时候都创建一个单例实例 getInstance:function(){ instance=init(); return instance; } }; })(); //使用： var singleA=mySingleton.getInstance(); var singleB=mySingleton.getInstance(); console.log(singA.getRandomNumber()===singleB.getRandomNumber()); //true var badSingleA=myBadSingleton.getInstance(); var badSingleB=myBadSingleton.getInstance(); console.log(badSingleA.getRandomNumber()!==badSingleB.getRandomNumber());//true //注意：因为我们使用的是随机数 //所以上面的值还是有可能相同的 //但是可能性很低，上面的例子还是有效的。 使用单例可以让我们有一个指向实例的统一入口（一般通过MySingleton.getInstance()的方式），这样我们就不需要直接通过new MySingleton()的方式直接调用啦。这在javascript中也是可以实现的。 在四人帮这本书中，单例的适用场景被描述为下面这些： 必须只有一个类的实例，而且必须可以通过大家都知道的入口让大家可以访问到。 当这个唯一的实例需要被之类扩展的时候，用户可以在不需要修改代码的情况下扩展它。 第二点指出了我们可能遇到的场景，比如： mySingleton.getInstance=function(){ if(this._instance==null){ if(isFoo()){ this._instance=new FooSingleton(); }else{ this._instance=new BasicSingleton(); } } return this._instance; } 这里，getInstance变得有些像工厂方法，我们访问它的时候并不需要更新我们的每一部分代码。上面的FooSingleton可能是BasicSingleton的之类，并且实现了同样的接口。 为什么在单例中延迟执行被认为很重要呢？： 在C++中，它被用来让我们解决动态初始化执行顺序的不可预测性，把控制权交给了程序。 需要注意的是区分类的静态实例和单例的区别是很重要的。尽管单例可以被实现成静态实例。但是同时也可以延迟构造，不需要消耗资源也不会消耗内存直到需要它的时候再初始化。 如果我们有一个可以被直接初始化的静态对象，我们需要确保代码是按照顺序执行的。（比如，车的对象初始化的时候车轮必须已经存在）并且它在你有很多资源文件的时候不会变大。 单例和静态对象都很有用，但是不能过度使用。就像不能过度使用其他模式一样。 实践中，当我们在整个系统中只需要一个对象与其他对象通信的时候，单例模式是非常有用的。下面就是单例在上下文中使用模式的一个例子： var SingletonTester = (function () { // options: an object containing configuration options for the singleton // e.g var options = { name: &quot;test&quot;, pointX: 5}; function Singleton( options ) { // set options to the options supplied // or an empty object if none are provided options = options || {}; // set some properties for our singleton this.name = &quot;SingletonTester&quot;; this.pointX = options.pointX || 6; this.pointY = options.pointY || 10; } // our instance holder var instance; // an emulation of static variables and methods var _static = { name: &quot;SingletonTester&quot;, // Method for getting an instance. It returns // a singleton instance of a singleton object getInstance: function( options ) { if( instance === undefined ) { instance = new Singleton( options ); } return instance; } }; return _static; })(); var singletonTest = SingletonTester.getInstance({ pointX: 5 }); // Log the output of pointX just to verify it is correct // Outputs: 5 console.log( singletonTest.pointX ); 尽管单例在这里使用时有效的，但是经常当我们需要在javascript中使用它的时候，往往意味着我们应该重新审视我们的设计啦。 他们往往意味着系统的模块要不就是耦合过紧啦，要么逻辑延伸的太大啦。单例的使用往往会让测试变得更加困难，因为存在隐藏依赖，难以创建多个实例，难以找到根依赖等问题。","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"},{"name":"设计模式","slug":"javascript/设计模式","permalink":"http://wangfulin.github.io/categories/javascript/设计模式/"}],"tags":[{"name":"javascript, 设计模式","slug":"javascript-设计模式","permalink":"http://wangfulin.github.io/tags/javascript-设计模式/"}]},{"title":"<译>设计模式：发布/订阅模式解析","slug":"design-patterns-pub-sub-explained-in-js","date":"2015-10-19T16:00:00.000Z","updated":"2016-04-28T07:58:10.000Z","comments":true,"path":"2015/10/20/design-patterns-pub-sub-explained-in-js/","link":"","permalink":"http://wangfulin.github.io/2015/10/20/design-patterns-pub-sub-explained-in-js/","excerpt":"","keywords":null,"text":"原文：Design Patterns:PubSub Explained 介绍这个模式用来作为中间人，一个把发布者和订阅者架接在一起的代理。发布者是当完成某些过程的时候触发事件的对象，订阅者是希望当发布者发布的时候希望被通知的对象。 生活中有一个很好地例子，广播电台，人们会把频道调到他们最喜欢的节目。广播站不知道观众听得是什么或者他们正在听什么。他只需要发布他们的节目就可以啦。观众也不知道广播站制作节目的过程。他们只要在他们最喜欢的节目运行的时候把台调到对应的频道或者告知朋友就行。 发布/订阅者模式实现了松耦合：你可以让发布者发布消息，订阅者接受消息而不是寻找一种方式把两个分离的系统连接在一起。 优势 松耦合 发布者不需要知道订阅者的数量，订阅者听得话题或者订阅者是通过什么方式运行的。他们能够相互独立地运行，这样就可以让你分开开发这两部分而不需要担心对状态或实现的任何细微的影响。 可扩展性 发布/订阅模式可以让系统在无论什么时候无法负载的时候扩展 更干净地设计 充分地利用好发布/订阅模式，你不得不深入地思考不同的组件是如何交互的。这通常会让我们有更干净地设计因为我们对解耦和松耦合的强调。 灵活性 你不需要担心不同的组件是如何组合在一起的。只要他们共同遵守一份协议 容易测试 你可以很好地找出发布者或订阅者是否会得到错误的信息 缺点发布/订阅模式最大的有点是解耦，但同时也是最大的缺点： 中间人也许不会通知系统消息传送的状态。所以我们无法知道消息传送是成功的还是失败的。紧耦合是需要保证这一点的。 发布者不知道订阅者的状态，反之亦然，这样的话，你根本不知道在另一端是否会没有问题？ 随着订阅者和发布者数量的增加，不断增加的消息传送回导致架构的不稳定，容易在负载大的时候出问题 攻击者（恶意的发布者）能够入侵系统并且撕开它。这会导致恶意的消息被发布，订阅者能够获得他们以前并不能获得的消息。 更新发布者和订阅者的关系会是一个很难的问题，因为毕竟他们根本不认识对方。 需要中间人/代理商，消息规范和相关的规则会给系统增加一些复杂度 结论现实没有银弹，但是这个模式是设计松耦合系统的很好地方式。这和RSS,Atom和PubSubHubbub的思想一样。 发布/订阅模式例子（Javascript） var makePubSub=function(){ var callbacks={}, publish=function(){ //Turn arguments object into real array var args=Array.prototype.slice.call(arguments,0); //Extract the event name which is the first entry var ev=args.shift(); //Return if callbacks object doesn&apos;t contain //any entry for event var list,i,l; if(!callbacks[ev]){ return this; } list=callbacks[ev]; //Invoke the callbacks,passing in the rest of parameters for(i=0,l=list.length;i&lt;l;i++){ list[i].apply(this,args); } return this; }, subscribe=function(ev,callback){ //Check if ev is already registered //If it isn&apos;t create an array entry for it if(!callbacks[ev]){ callbacks[ev]=[]; } callbacks[ev].push(callback); return this; }; return {pub:publish,sub:subscribe}; } test=makePubSub(); test.sub(&quot;alert&quot;,function(){alert(&quot;hell0&quot;);}) test.pub(&quot;alert&quot;);","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"},{"name":"设计模式","slug":"javascript/设计模式","permalink":"http://wangfulin.github.io/categories/javascript/设计模式/"}],"tags":[{"name":"javascript, 设计模式","slug":"javascript-设计模式","permalink":"http://wangfulin.github.io/tags/javascript-设计模式/"}]},{"title":"<译>用CSS来禁止文本选择","slug":"disable-text-selection","date":"2015-09-19T16:00:00.000Z","updated":"2016-04-28T07:58:16.000Z","comments":true,"path":"2015/09/20/disable-text-selection/","link":"","permalink":"http://wangfulin.github.io/2015/09/20/disable-text-selection/","excerpt":"","keywords":null,"text":"原文：Disable Text Selection with CSS 有些时候我们需要禁止网页的部分文本不能被选择。你可以使用user-select这个CSS特性来实现这个需求。 举例下面是一个使用了disable-selection类的样式规则，当它作用于一个HTML元素的时候，它会让我们不能够选择这个元素。 .disable-selection{ -moz-user-select:none; /* Firefox */ -ms-user-select:none; /* Internet Explorer */ -ktml-user-select:none; /* KHTML浏览器（比如：Konqueror） */ -webkit-user-select:none; /* Chrome,Safari,and Opera */ -webkit-touch-callout:none; /* Disable Android and IOS callout */ } 关于这些样式的一些细节的解释： -webkit-user-select是给Chrome,Safari和Opera用的（并不需要使用-o-user-select）。 没有前缀的user-select是被故意略去的。 -webkit-touch-callout属性可以让在移动设备上的触摸后弹出失效。就像下面的这些，我们可以让它们不能出现。 演示 查看演示 要时常记住的有一个陷阱就是：user-select并不是W3C规范中标准的CSS特性。尽管user-select通过添加浏览器前缀有很好的浏览器支持。 前面的例子中，我没有使用没有前缀的user-select特性声明。那是因为在web标准中根本就没有这个属性。我们可以对它的使用类比于于IE专有的CSS属性ms-filter或者-ms-text-kashida-space的属性的使用。 其他需要注意的地方： user-select是有问题并且是不稳定的。有些时候你依然还是可以选择文本，特别是当你从没有被屏蔽掉文本选择的文本的那部分开始选择。 使用全选快捷键有些时候还是会把屏蔽文本选择(Win:Ctrl+A/Mac:Cmd+A)。这种情况你可以在IE11中清楚的了解到。 这不是一种万全的保证文本不被选择的策略。CSS能够很容易被屏蔽。这种技巧依赖于非标准的CSS特性，这意味着未来对这个属性的可持续支持上面存在着很大的不确定性。 屏蔽掉文本选择是很恼人的。我会在渐进提升的过程中使用这个技巧：只有当它可以提高使用支持这个user-select特性的浏览器和设备的用户的用户体验的时候才使用它。但是，我绝不会把它设置成一个大范围的CSS选择器像全部选择器(*）或者body. 这个user-select特性可能会让你的样式表失效。如果遵循标准对你来说非常重要，使用这个属性会在你使用规范测试比如说CSS Validation Service的使用出现问题 浏览器支持更新于：2015年3月 浏览器 版本支持（以上） Chrome 6 Firefox 2 IE 10 Safari 3.1 移动端|浏览器|版本支持（以上）||:——|:—–||Chrome(Android)|2.1||Safari(IOS)|3.2|","raw":null,"content":null,"categories":[{"name":"CSS","slug":"CSS","permalink":"http://wangfulin.github.io/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://wangfulin.github.io/tags/css/"}]},{"title":"<译>简单的用javascript实现的数据双向绑定","slug":"easy-two-way-data-binding-in-javascript","date":"2015-08-19T16:00:00.000Z","updated":"2016-04-28T07:58:27.000Z","comments":true,"path":"2015/08/20/easy-two-way-data-binding-in-javascript/","link":"","permalink":"http://wangfulin.github.io/2015/08/20/easy-two-way-data-binding-in-javascript/","excerpt":"","keywords":null,"text":"原文：Easy Two-Way Data Binding in Javascript 双向数据绑定指的是当对象的属性发生变化时能够同时改变对应的UI，反之亦然。换句话说，如果我们有一个user对象，这个对象有一个name属性，无论何时你对user.name设置了一个新值，UI也会展示这个新的值。同样的，如果UI包含一个用于数据用户名字的输入框，输入一个新值也会导致user对象的name属性发生相应的改变。 许多流行的javascript框架，像Ember.js,Angular.js或者KnockoutJS都会把双向数据绑定作为其中的主要特性来宣传。这并不意味着从头开始实现它很难，也不意味着当我们需要这种功能的时候，使用这些框架是我们唯一的选择。内部的潜在思想事实上是相当基础的，实现它可以归纳为以下三点： 我们需要一种方式确定哪个UI元素绑定在哪个属性上。 我们需要监控属性和UI的变化 我们需要把所有绑定的对象和UI元素的变化传播出去。 尽管有好多种方式去实现这几点，一种简单高效的方法是我们通过发布订阅者模式来实现。方法很简单：我们可以使用定制的data属性作为HTML代码中需要绑定的属性。所有的绑定在一起的Javascript对象和DOM元素将会订阅这个发布订阅对象。任何时候我们检测到无论是Javascript对象亦或是HTML的input元素的变化，我们都是把事件代理传递给发布订阅对象，然后通过它把所有发生在绑定的对象和元素的的变化传递和广播出去。 一个用jQuery实现的简单例子通过jQuery实现我们上面讨论的东西是相当简单明了的，因为作为一个流行的库，它让我们很简单的实现订阅和发布DOM事件，同时我们也可以定制一个： function DataBinder(object_id){ // Use a jQuery object as simple PubSub var pubSub=jQuery({}); // We expect a `data` element specifying the binding // in the form:data-bind-&lt;object_id&gt;=&quot;&lt;property_name&gt;&quot; var data_attr=&quot;bind-&quot;+object_id, message=object_id+&quot;:change&quot;; // Listen to chagne events on elements with data-binding attribute and proxy // then to the PubSub, so that the change is &quot;broadcasted&quot; to all connected objects jQuery(document).on(&quot;change&quot;,&quot;[data-]&quot;+data_attr+&quot;]&quot;,function(eve){ var $input=jQuery(this); pubSub.trigger(message,[$input.data(data_attr),$input.val()]); }); // PubSub propagates chagnes to all bound elemetns,setting value of // input tags or HTML content of other tags pubSub.on(message,function(evt,prop_name,new_val){ jQuery(&quot;[data-&quot;+data_attr+&quot;=&quot;+prop_name+&quot;]&quot;).each(function(){ var $bound=jQuery(this); if($bound.is(&quot;&quot;)){ $bound.val(new_val); }else{ $bound.html(new_val); } }); }); return pubSub; } 至于javascript对象，下面是最小化的user数据模型实现的例子： function User(uid){ var binder=new DataBinder(uid), user={ attributes:{}, // The attribute setter publish changes using the DataBinder PubSub set:function(attr_name,val){ this.attributes[attr_name]=val; binder.trigger(uid+&quot;:change&quot;,[attr_name,val,this]); }, get:function(attr_name){ return this.attributes[attr_name]; }, _binder:binder }; // Subscribe to PubSub binder.on(uid+&quot;:change&quot;,function(evt,attr_name,new_val,initiator){ if(initiator!==user){ user.set(attr_name,new_val); } }); return user; } 现在，无论何时我们想要绑定一个对象的属性到UI上，我们只要在对应的HTML元素上设置合适的data属性。 // javascript var user=new User(123); user.set(&quot;name&quot;,&quot;Wolfgang&quot;); // html &lt;input type=&quot;number&quot; data-bind-123=&quot;name&quot; /&gt; input输入框上值得变化会自动的映射到user的name属性，反之亦然。大功告成！ 不需要jQuery的实现方式现在的大部分项目一般jQuery都已经在使用啦，所以上面的例子是完全可以接受的。但是如果我们需要完全不依赖jQuery，那么该怎么实现呢？好吧，事实上其实也不难办到（特别是当我们把对IE的支持只提供IE8以上的支持）。最后，我们只是要通过发布订阅者模式来观察DOM事件而已。 function DataBinder( object_id ) { // Create a simple PubSub object var pubSub = { callbacks: {}, on: function( msg, callback ) { this.callbacks[ msg ] = this.callbacks[ msg ] || []; this.callbacks[ msg ].push( callback ); }, publish: function( msg ) { this.callbacks[ msg ] = this.callbacks[ msg ] || [] for ( var i = 0, len = this.callbacks[ msg ].length; i &lt; len; i++ ) { this.callbacks[ msg ][ i ].apply( this, arguments ); } } }, data_attr = &quot;data-bind-&quot; + object_id, message = object_id + &quot;:change&quot;, changeHandler = function( evt ) { var target = evt.target || evt.srcElement, // IE8 compatibility prop_name = target.getAttribute( data_attr ); if ( prop_name &amp;&amp; prop_name !== &quot;&quot; ) { pubSub.publish( message, prop_name, target.value ); } }; // Listen to change events and proxy to PubSub if ( document.addEventListener ) { document.addEventListener( &quot;change&quot;, changeHandler, false ); } else { // IE8 uses attachEvent instead of addEventListener document.attachEvent( &quot;onchange&quot;, changeHandler ); } // PubSub propagates changes to all bound elements pubSub.on( message, function( evt, prop_name, new_val ) { var elements = document.querySelectorAll(&quot;[&quot; + data_attr + &quot;=&quot; + prop_name + &quot;]&quot;), tag_name; for ( var i = 0, len = elements.length; i &lt; len; i++ ) { tag_name = elements[ i ].tagName.toLowerCase(); if ( tag_name === &quot;input&quot; || tag_name === &quot;textarea&quot; || tag_name === &quot;select&quot; ) { elements[ i ].value = new_val; } else { elements[ i ].innerHTML = new_val; } } }); return pubSub; } 数据模型可以保持不变，除了在setter中对jQuery中trigger方法的调用，我们可以通过我们在PubSub中自定义的publish方法来代替。 // In the model&apos;s setter: function User( uid ) { // ... user = { // ... set: function( attr_name, val ) { this.attributes[ attr_name ] = val; // Use the `publish` method binder.publish( uid + &quot;:change&quot;, attr_name, val, this ); } } // ... } 我们又一次通过一百行不到，又可维护的纯javascript完成了我们想要的结果。","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"},{"name":"设计模式","slug":"javascript/设计模式","permalink":"http://wangfulin.github.io/categories/javascript/设计模式/"}],"tags":[{"name":"javascript, 设计模式","slug":"javascript-设计模式","permalink":"http://wangfulin.github.io/tags/javascript-设计模式/"}]},{"title":"<译>jQuery事件绑定的最佳实践","slug":"Effective Event Binding with jQuery","date":"2015-06-19T16:00:00.000Z","updated":"2016-04-28T07:58:40.000Z","comments":true,"path":"2015/06/20/Effective Event Binding with jQuery/","link":"","permalink":"http://wangfulin.github.io/2015/06/20/Effective Event Binding with jQuery/","excerpt":"","keywords":null,"text":"原文：Effective Event Binding with jQuery 如果你经常使用jQuery，那么你也许很熟悉事件绑定。这是很基本的东西，但是深入一点，你就能够找到机会让你事件驱动的代码变得不太零碎，并且更容易管理。 更好的选择器策略让我们从基础的例子开始。下面的HTML代码表示的是可以开合的导航菜单。 &lt;button class=&quot;nav-menu-toggle&quot;&gt;Toggle Nav Menu&lt;/button&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;West Philadelphia&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/cab&quot;&gt;Cab Whistling&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/throne&quot;&gt;Throne Sitting&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; 下面这个是点击按钮之后控制导航菜单开合的javascript代码 $(&apos;.nav-menu-toggle&apos;).on(&apos;click&apos;,function(){ $(&apos;nav&apos;).toggle(); }); 这可能是最常用的实现方式。它能够使用，但是比较脆。javascript代码依赖了按钮的类名nav-menu-toggle。很可能在未来其他开发者或者健忘的你在重构代码的时候会删除或者重命名这个类名。 问题的核心是我们同时在表现和交互中使用了CSS的类名。这违反了关注点分离的原则，让维护更容易出错。 让我们用一个不同的方法来实现 &lt;button data-hook=&quot;nav-menu-toggle&quot;&gt;Toggle Nav Menu&lt;/button&gt; &lt;nav data-hook=&quot;nav-menu&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;West Philadelphia&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/cab&quot;&gt;Cab Whistling&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/throne&quot;&gt;Throne Sitting&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; 这次我们使用这个data属性（data-hook）来选择元素。任何对CSS类的改变将不会影响到javascript，让我们能够实现关注点分离以及更加稳定的代码。 下面我们用data-hook属性来选择对应的元素： $(&apos;[data-hook=&quot;nav-menu-toggle&quot;]&apos;).on(&apos;click&apos;,function(){ $(&apos;[data-hook=&quot;nav-menu&quot;]&apos;).toggle(); }); 需要注意的是，我也使用data-hook作为nav元素的选择器。你不一定需要，但是我喜欢这里面包含的思想：任何使用你看到data-hook，你会知道这个元素在javascript中引用到啦。 一些语法糖我必须承认data-hook选择器并不是很漂亮。让我们通过扩展jQuery实现一个自定义的函数： $.extend({ hook:function(hookName){ var selector; if(!hookName || hookName === &apos;*&apos;){ // select all data-hooks selector=&apos;[data-hook]&apos; }else{ // select specific data-hook selector=&apos;[data-hook*=&quot;&apos;+hookName+&apos;&quot;]&apos;; } return $(selector); } }); 上面准备完毕，我们来重写一下javascript。 $.hook(&apos;nav-menu-toggle&apos;).on(&apos;&apos;,function(){ $.hook(&apos;nav-menu&apos;).toggle(); }); 更好的是，我们甚至可以把一系列以空格分开的hook名字放在一个元素上。 &lt;button data-hook=&quot;nav-menu-toggle video-pause click-track&quot;&gt;Toggle Nav Menu&lt;/button&gt; 我们可以找到里面的任意个hook名字： $.hook(‘click-track’); // returns the button as expected 我们也能够找到页面上所有的hook元素 // both are equivalent $.hook(); $.hook(&apos;*&apos;); 防止函数表达式到目前为止，我们在事件处理中使用的都是匿名函数。让我们重写一下，使用声明的函数来代替它。 function toggleNavMenu(){ $.hook(&apos;nav-menu&apos;).toggle(); } $.hook(&apos;nav-menu-toggle&apos;).on(&apos;click&apos;,toggleNavMenu); 这让事件绑定的代码更加易读。这个toggleNavMenu函数名表达了意图，是代码自我注释的好例子。 我们同时也获得了可复用的能力，因为其他地方可能需要使用toggleNavMenu函数。 最后，这对于自动化测试来说是意见大喜事，因为声明的函数的单元测试要比匿名函数单元测试容易的多。 同时使用多个事件jQuery提供了一个简单方便的语法来处理多事件的问题。比如，你可以为一系列空格隔开的事件列表绑定同一个事件处理函数。 $.hook(&apos;nav-menu-toggle&apos;).on(&apos;click keydown mouseenter&apos;,trackAction); 如果你需要为不同的事件绑定不同的处理函数，你可以使用对象表达方式： $.hook(‘nav-menu-toggle’).on({ ‘click’:trackClick, ‘keydown’:tranckKeyDown, ‘mouseenter’:trackMouseEnter }); 反过来，你可以同时取消多个事件的绑定： // unbinds keydown and mouseenter $.hook(&apos;nav-menu-toggle&apos;).off(&apos;keydown mouseenter&apos;); // nuclear options:unbinds everything $.hook(&apos;nav-menu-toggle&apos;).off(); 你可以想象到的是，不小心的取消事件绑定可能会导致严重的我们不想要的副作用。继续看我们可以通过哪些技巧来减轻这个问题。 小心的取消事件绑定一般情况下我们不会在一个元素的同一事件类型绑定多个事件处理函数。让我们再看一下之前的那个按钮： &lt;button data-hook=&quot;nav-menu-toggle video-pause click-track&quot;&gt;Toggle Nav Menu&lt;/button&gt; 不同的代码区域可能会在同一个元素的同一事件绑定不同的事件处理函数： // somewhere in the nav code $.hook(&apos;nav-menu-toggle&apos;).on(&apos;click&apos;,toggleNavMenu); // somewhere in the video playback code $.hook(&apos;video-pause&apos;).on(&apos;click&apos;,pauseCarltonDanceVideo); // somewhere in the analytics code $.hook(&apos;click-track&apos;).on(&apos;click&apos;,trackClick); 尽管我们使用了不同的选择器，但是这个元素现在有三个事件处理函数啦。假如我们的分析代码不在关心这个按钮： // no good $.hook(&apos;click-track&apos;).off(&apos;click&apos;); 糟糕的是，上面的代码实际上回删除所有的点击事件处理函数，不仅仅是trackClick。我们应该实用更加有辨别力的方式来指定我们需要删除的事件处理函数： $.hook(&apos;click-track&apos;).off(&apos;click&apos;,trackClick); 另一种方式是使用命名空间。任何事件都有资格使用一个命名空间来实现绑定和取消绑定，这样你就可以更好的控制事件绑定和取消绑定。 // binds a click event in the &quot;analytics&quot; namespace $.hook(&apos;click-track&apos;).on(&apos;click.analytics&apos;, trackClick); // unbinds only click events in the &quot;analytics&quot; namespace $.hook(&apos;click-track&apos;).off(&apos;click.analytics&apos;); 你也可以使用多个命名空间： // binds a click event in both the &quot;analytics&quot; and &quot;usability&quot; namespaces $.hook(&apos;click-track&apos;).on(&apos;click.analytics.usability&apos;,trackClick); // unbinds any events in either the &quot;analytics&quot; OR &quot;usability&quot; namespaces $.hook(&apos;click-track&apos;).off(&apos;.usability .analytics&apos;); // unbinds any events in both the &quot;analytics&quot; AND &quot;usability&quot; namespaces $.hook(&apos;click-track&apos;).off(&apos;.usability.analytics&apos;); 需要注意的是，命名空间的顺序是没有关系的，因为命名空间不是层级式的。 如果你有一个复杂的功能需要多个元素绑定多个事件，那么使用命名空间是一种简单的把他们组织起来然后快速清除的方式： // free all elements on the page of any &quot;analytics&quot; event handling $(&apos;*&apos;).off(&apos;.analytics&apos;); 命名空间在写插件的时候尤其有用，因为这样你就能保证只会取消自己命名空间范围内的事件处理函数的绑定。","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"},{"name":"jQuery","slug":"javascript/jQuery","permalink":"http://wangfulin.github.io/categories/javascript/jQuery/"}],"tags":[{"name":"javascript, jQuery","slug":"javascript-jQuery","permalink":"http://wangfulin.github.io/tags/javascript-jQuery/"}]},{"title":"Web字体的初探","slug":"Font","date":"2015-05-19T16:00:00.000Z","updated":"2016-04-28T07:58:48.000Z","comments":true,"path":"2015/05/20/Font/","link":"","permalink":"http://wangfulin.github.io/2015/05/20/Font/","excerpt":"","keywords":null,"text":"一，字体基本概念的介绍1.1 字体的分类 1.1.1 Serif（衬线体）Serif（衬线）：在印刷的文字中衬线字体对于人眼的辨识更轻松，阅读更舒服横细竖粗，开始和结束的地方有装饰。在web上的字体，衬线字体比无衬线字体的辨识度更低，因为屏幕像素有限，不能很好地渲染出衬线体的效果。 1.1.2 Sans-Serif（无衬线体)Sans-Serif(无衬线体）：在印刷的文字中，无衬线体比较醒目，在小字体场合比衬线体更加清晰，但是辨识度没有衬线体高。在web字体中，无衬线字体比衬线字体更易读。 1.1.3 Monospace（等宽字体）Monospace（等宽字体）：每个宽度都一致的字体，看起来比较整齐，比较适合用于显示代码。比较著名的有Courier New字体。 1.1.4 Cursive（草书）Cursive（草书）：相当于印刷中的手写体，看起来比较流畅，像手写一样。 1.2 常用的字体Serif，Sans-Serif，Monospace属于标准字体，Cursive,Fantasy属于非标准字体 1.2.1 衬线体（Serif）常用的中文衬线体：宋体（Simsun），仿宋（FangSong），楷体（KaiTi），华文仿宋（STFangSong），华文楷体（STKaiTi）。 常见的英文衬线体：Times new Roman，Times 1.2.2 无衬线体（Sans-Serif）常见的中文无衬线体：微软雅黑（Microsoft YaHei），黑体（SimHei），华文细黑（STXiHei） 常见的英文无衬线体：Tahoma，Arial，Helvetica，Verdana 1.2.3 等宽字体（monospace）常见的等宽字体：Courier New，Courier 1.2.4 草书（Cursive）常见的草书：Comic Sans MS 1.2.5 Fantasy常见的Fantasy：Impact 二，网站中使用的字体2.1 英文网站中使用的默认字体font：12px/1.5 Tahoma,Helvetica,Arial,sans-serif Tahoma：英文windows操作系统默认的字体 Helvetica：Mac OS X系统的系统默认字体 Arial：早期windows英文系统的默认字体。XP和Vista都是Tahoma Sans-serif是针对linux的，linux默认只有kernel，字体由用户自定义。 无论是XP还是Vista下，不指定网页的中文字体时，默认的就是宋体。因此在font-family中使用”宋体“是多余的，可以省去。 2.2 Windows操作系统提供的中文字体黑体：SimHei 宋体：SimSun 新宋体：NSimSun 仿宋：FangSong 楷体：KaiTi 仿宋GB2312：FangSongGB2312 楷体GB2312：KaiTiGB2312 微软雅黑：Microsoft YaHei(Windows 7开始提供） 2.3 OS X操作系统提供的中文字体冬青黑体：Hiragino Sans GB（Snow Leopard开始提供） 华文细黑：STHeiti Light（又名STXiHei） 华文黑体：STHeiTi 华文楷体：STKaiTi 华文宋体：STSong 华文仿宋：STFangsong 2.4 更多有趣的字体使用上面介绍的字体属于常见的字体，也就是我们所说的Web safe font。其在大部分网站是可以正常显示的。下面介绍的是比较有趣特殊的字体的使用方式。 2.5 使用web font的方法2.5.1 使用link标签通过link导入样式，然后直接通过font-family使用，如： &lt;link href=&#39;https://fonts.googleapis.com/css?family=Lobster&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&gt; font-family:&quot;lobster&quot; 参考Google Fonts 2.5.2 使用@import导入通过@import导入字体的样式，如： @import url(https://fonts.googleapis.com/css?family=Candal); font-family:&quot;Candal&quot; 参考Google Fonts 2.5.3 使用javascript通过javascript获取字体样式，如： &lt;script type=&quot;text/javascript&quot;&gt; WebFontConfig = { google: { families: [ &apos;Shadows+Into+Light::latin&apos; ] } }; (function() { var wf = document.createElement(&apos;script&apos;); wf.src = (&apos;https:&apos; == document.location.protocol ? &apos;https&apos; : &apos;http&apos;) + &apos;://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js&apos;; wf.type = &apos;text/javascript&apos;; wf.async = &apos;true&apos;; var s = document.getElementsByTagName(&apos;script&apos;)[0]; s.parentNode.insertBefore(wf, s); })(); &lt;/script&gt; font-family:&quot;Shadows Into Light&quot; 参考Google Fonts 2.5.4 使用font-face首先需要从网站下载对应的字体，然后url填入文件路径，如： @font-face{ font-family:&quot;saucer&quot;; src:url(&quot;fonts/SaucerBB.ttf&quot;) format(&quot;truetype&quot;); }font-family:saucer; 2.5.5 使用这些特殊字体的弊端使用这些特殊字体可以产生很炫酷的文字，但是也存在很大的弊端： 1，不同的环境显示的内容可能不一样 2，显示的内容不可靠 3，需要把字体包含到网站（有时可能有100kb大）中需要消耗大量的下载时间 三，大型网站上的字体实践1.淘宝：font-family: tahoma, arial, &apos;Hiragino Sans GB&apos;, 宋体, sans-serif; 2.百度：font-family: arial, 宋体, &apos;Hiragino Sans GB&apos;, &apos;Microsoft Yahei&apos;, 微软雅黑, 宋体, Tahoma, Arial, Helvetica, STHeiti; 3.京东：font-family: Arial, Verdana, 宋体； 4.Youtube：font-family: Roboto, arial, sans-serif; 5.github：font-family: Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, &apos;Segoe UI Emoji&apos;, &apos;Segoe UI Symbol&apos;; 参考的网站： creating good websites serif和sans-serif的区别 中文字体网页开发指南","raw":null,"content":null,"categories":[{"name":"CSS","slug":"CSS","permalink":"http://wangfulin.github.io/categories/CSS/"},{"name":"font","slug":"CSS/font","permalink":"http://wangfulin.github.io/categories/CSS/font/"}],"tags":[{"name":"web, CSS","slug":"web-CSS","permalink":"http://wangfulin.github.io/tags/web-CSS/"}]},{"title":"<译> ES6 生成器基础","slug":"The Basics Of ES6 Generators","date":"2015-05-03T16:00:00.000Z","updated":"2016-04-28T08:00:47.000Z","comments":true,"path":"2015/05/04/The Basics Of ES6 Generators/","link":"","permalink":"http://wangfulin.github.io/2015/05/04/The Basics Of ES6 Generators/","excerpt":"","keywords":null,"text":"原文:The Basics Of ES6 Generators","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"},{"name":"ES6","slug":"javascript/ES6","permalink":"http://wangfulin.github.io/categories/javascript/ES6/"}],"tags":[{"name":"javascript, es6","slug":"javascript-es6","permalink":"http://wangfulin.github.io/tags/javascript-es6/"}]},{"title":"出现次数最多的字符","slug":"get-most-appearance-times","date":"2015-04-19T16:00:00.000Z","updated":"2016-04-28T07:58:54.000Z","comments":true,"path":"2015/04/20/get-most-appearance-times/","link":"","permalink":"http://wangfulin.github.io/2015/04/20/get-most-appearance-times/","excerpt":"","keywords":null,"text":"问题：给定一个字符串，求出里面出现次数最多的字符。 输入：字符串 输出：{[字符]:[出现次数],…} 举例：输入：&#39;hello world&#39; 输出：{&#39;l&#39;:3} 方法1: 先排序，然后单次遍历 12345678910111213141516171819202122232425262728293031function getMostAppear(str)&#123; if(str.length === 0) return &#123;&#125;; var sortedArr = str.split('').sort(function(a, b)&#123; return a - b; &#125;); var len = sortedArr.length; // 用来记录最多的次数 var max = 0; // 用来记录出现最多次数的字符 var c = ''; // 用来记录当前字符和次数的映射 var currAppear = &#123;&#125;; for(var i = 0; i &lt; len; i++)&#123; var currChar = sortedArr[i]; if(!currAppear[currChar])&#123; currAppear[currChar] = 1; &#125;else&#123; currAppear[currChar]++; &#125; if(currAppear[currChar] &gt; max)&#123; max = currAppear[currChar]; c = currChar; &#125; &#125; var mostAppear = &#123;&#125;; mostAppear[c] = max; return mostAppear;&#125; 方法2: 12345678910111213141516171819202122232425262728293031function getMostAppear(str)&#123; if(str.length === 0) return &#123;&#125;; var len = str.length; // 用来记录最多的次数 var max = 0; // 用来记录出现最多次数的字符 var c = ''; // 字符和出现次数的映射 var charNumMap = &#123;&#125;; for(var i = 0; i &lt; len; i++)&#123; var curr = str.charAt(i); if(!charNumMap[curr])&#123; charNumMap[curr] = 1; &#125;else&#123; charNumMap[curr]++; &#125; if(charNumMap[curr] &gt; max)&#123; max = charNumMap[curr]; c = curr; &#125; &#125; var mostAppear = &#123;&#125;; mostAppear[c] = max; return mostAppear;&#125;","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"},{"name":"面试题","slug":"javascript/面试题","permalink":"http://wangfulin.github.io/categories/javascript/面试题/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/tags/javascript/"}]},{"title":"gulp的简介","slug":"gulp","date":"2015-03-19T16:00:00.000Z","updated":"2016-04-28T07:59:00.000Z","comments":true,"path":"2015/03/20/gulp/","link":"","permalink":"http://wangfulin.github.io/2015/03/20/gulp/","excerpt":"","keywords":null,"text":"什么是gulpgulp是在你的开发过程中用来帮你自动化一些麻烦耗时的工作的工具集。比如在web开发过程中，它能帮你完成css预处理，js文件整合，压缩，实时重加载等等。并且它还和目前市场上主流的IDE整合，无论是在PHP,.NET,Node.js,Java等等开发者都很喜欢用它。拥有超过1700中插件，gulp能够让你从繁琐的构建系统中解脱出来，真正的开始干活。 怎样开始 安装Node.js 创建一个项目，比如说gulptest 在控制台项目路径下，npm init，跟着步骤创建package.json文件 npm install –global gulp，使gulp命令可以在命令行中使用。 npm install –save-dev gulp，在项目上安装gulp模块，同时将 gulp添加到package.json的dev-dependencies依赖中。 比如我们需要压缩css文件，先安装需要的模块npm install –save-dev gulp-minify-css 在项目路径下创建gulpfile.js var gulp = require(&apos;gulp&apos;); var minifyCss = require(&apos;gulp-minify-css&apos;); gulp.task(&apos;minify-css&apos;, function() { return gulp.src(&apos;styles/*.css&apos;) .pipe(minifyCss({compatibility: &apos;ie8&apos;})) .pipe(gulp.dest(&apos;dist&apos;)); }); 运行gulp minify-css命令 gulp API跳转到：gulp.src | gulp.dest | gulp.task |gulp.watch gulp.src Emits files matching provided glob or an array of globs. Returns a stream of Vinyl files that can be piped to plugins. gulp.src(&apos;client/templates/*.jade&apos;) .pipe(jade()) .pipe(minify()) .pipe(gulp.dest(&apos;build/minified_templates&apos;)); 根据路径找到文件然后把它放在流里面pipe到gulp插件 gulp.src(&apos;client/js/**/*.js&apos;) // Matches &apos;client/js/somedir/somefile.js&apos; and resolves `base` to `client/js/` .pipe(minify()) .pipe(gulp.dest(&apos;build&apos;)); // Writes &apos;build/somedir/somefile.js&apos; gulp.src(&apos;client/js/**/*.js&apos;, { base: &apos;client&apos; }) .pipe(minify()) .pipe(gulp.dest(&apos;build&apos;)); // Writes &apos;build/js/somedir/somefile.js&apos; gulp.dest Can be piped to and it will write files. Re-emits all data passed to it so you can pipe to multiple folders. Folders that don’t exist will be created. gulp.src(&apos;./client/templates/*.jade&apos;) .pipe(jade()) .pipe(gulp.dest(&apos;./build/templates&apos;)) .pipe(minify()) .pipe(gulp.dest(&apos;./build/minified_templates&apos;)); gulp.task Define a task using Orchestrator. gulp.task(&apos;somename&apos;, function() { // Do stuff }); An array of tasks to be executed and completed before your task will run. gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() { // Do stuff }); You can also omit the function if you only want to run the dependency tasks: gulp.task(&apos;build&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;]); Accept a callback // run a command in a shell var exec = require(&apos;child_process&apos;).exec; gulp.task(&apos;jekyll&apos;, function(cb) { // build Jekyll exec(&apos;jekyll build&apos;, function(err) { if (err) return cb(err); // return error cb(); // finished task }); }); Return a stream gulp.task(&apos;somename&apos;, function() { var stream = gulp.src(&apos;client/**/*.js&apos;) .pipe(minify()) .pipe(gulp.dest(&apos;build&apos;)); return stream; }); Return a promise var Q = require(&apos;q&apos;); gulp.task(&apos;somename&apos;, function() { var deferred = Q.defer(); // do async stuff setTimeout(function() { deferred.resolve(); }, 1); return deferred.promise; }); 默认情况下task中的任务是同步进行的，所以，如果需要在保证某一项任务在其他之前可以按照如下操作： var gulp = require(&apos;gulp&apos;); // takes in a callback so the engine knows when it&apos;ll be done gulp.task(&apos;one&apos;, function(cb) { // do stuff -- async or otherwise cb(err); // if err is not null and not undefined, the run will stop, and note that it failed }); // identifies a dependent task must be complete before this one begins gulp.task(&apos;two&apos;, [&apos;one&apos;], function() { // task &apos;one&apos; is done now }); gulp.task(&apos;default&apos;, [&apos;one&apos;, &apos;two&apos;]); gulp.watch Watch files and do something when a file changes. This always returns an EventEmitter that emits change events. Names of task(s) to run when a file changes, added with gulp.task() var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]); watcher.on(&apos;change&apos;, function(event) { console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;); }); 常用的gulp plugins 编译Sass gulp-ruby-sass 自动添加前缀 gulp-autoprefixer 压缩CSS gulp-minify-css JSHint gulp-jshint Concatenation gulp-concat Uglify gulp-uglify 图片压缩 gulp-imagemin 实时重加载 gulp-livereload 图片缓存从而只压缩改变的图片 gulp-cache Notify of changes gulp-notify 清除文件干净地构建 del 参考链接： github-gulp gulp-documentation","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"},{"name":"gulp","slug":"javascript/gulp","permalink":"http://wangfulin.github.io/categories/javascript/gulp/"}],"tags":[{"name":"javascript, gulp","slug":"javascript-gulp","permalink":"http://wangfulin.github.io/tags/javascript-gulp/"}]},{"title":"<译>javascript的闭包是怎么工作的？","slug":"how-do-javascript-closure-work","date":"2015-02-19T16:00:00.000Z","updated":"2016-04-28T07:59:05.000Z","comments":true,"path":"2015/02/20/how-do-javascript-closure-work/","link":"","permalink":"http://wangfulin.github.io/2015/02/20/how-do-javascript-closure-work/","excerpt":"","keywords":null,"text":"原文：how to javascript closure work","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"}],"tags":[{"name":"javascript, closure","slug":"javascript-closure","permalink":"http://wangfulin.github.io/tags/javascript-closure/"}]},{"title":"Ajax 源码解析","slug":"jquery-ajax-analyze","date":"2015-01-19T16:00:00.000Z","updated":"2016-04-28T07:59:13.000Z","comments":true,"path":"2015/01/20/jquery-ajax-analyze/","link":"","permalink":"http://wangfulin.github.io/2015/01/20/jquery-ajax-analyze/","excerpt":"","keywords":null,"text":"Ajax 是什么？ 客户端用来创建异步 web 应用的技术集合。web 应用可以异步地向服务器发送数据或者获取内容。 Ajax 做了什么？ 提供了快捷的接口 简单性 统一性 屏蔽了浏览器差异性 添加了默认的设置 提供全局 Ajax 事件处理 Ajax 部分的设计思路？Ajax 核心源码解读","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"},{"name":"jQuery","slug":"javascript/jQuery","permalink":"http://wangfulin.github.io/categories/javascript/jQuery/"},{"name":"Ajax","slug":"javascript/jQuery/Ajax","permalink":"http://wangfulin.github.io/categories/javascript/jQuery/Ajax/"}],"tags":[{"name":"javascript, jQuery, Ajax","slug":"javascript-jQuery-Ajax","permalink":"http://wangfulin.github.io/tags/javascript-jQuery-Ajax/"}]},{"title":"JS模块化初探","slug":"JS_Module","date":"2014-12-19T16:00:00.000Z","updated":"2016-04-28T07:59:19.000Z","comments":true,"path":"2014/12/20/JS_Module/","link":"","permalink":"http://wangfulin.github.io/2014/12/20/JS_Module/","excerpt":"","keywords":null,"text":"JS模块化初探什么是JS模块化JS模块化有什么好处JS模块化实践","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"},{"name":"模块化","slug":"javascript/模块化","permalink":"http://wangfulin.github.io/categories/javascript/模块化/"}],"tags":[{"name":"javascript, 模块化","slug":"javascript-模块化","permalink":"http://wangfulin.github.io/tags/javascript-模块化/"}]},{"title":"<译> Node.js 教程","slug":"node-js-promise-generator-event","date":"2014-11-19T16:00:00.000Z","updated":"2016-04-28T07:59:41.000Z","comments":true,"path":"2014/11/20/node-js-promise-generator-event/","link":"","permalink":"http://wangfulin.github.io/2014/11/20/node-js-promise-generator-event/","excerpt":"","keywords":null,"text":"[译]Node.js Tutorial: Promise, Generator, Event and Filestream 在前面的教程中，你已经看到了我们在异步事件中使用回调函数。但是有些时候当它们开始不断嵌套，并且程序变得越来越长越来越复杂的时候，回调函数就会像恶梦一般。 在这些情况下，Node.js 提供了额外的特性来修复我们在使用回调的时候遇到的问题。这些特性被分成 Promise, generates 和 events. 这篇文章我们会更详细地学习和理解这些概念。 什么是 promises在我们开始讲 promises 之前，让我们首先来回顾一下 Node.js 中 “callback” 是什么。我们在前面的章节中看到过很多，所以让我们快速地过一下其中的一个。 下面的例子展示了一段代码片段，它被用来连接一个 MongoDB 的数据库，并且在数据库的一条记录中执行更新操作。 代码解释： 上面的代码中，function(err,db) 这段代码被称作匿名函数的声明或者回调函数。当 MongoClient 创建了一个 MongoDB 数据库的连接时，一旦这个连接操作结束，它就会返回到回调函数执行。所以，某种意义上来说，连接操作在后台运行，并且当它结束之后，就会调用这个回调函数。记住这是之所以 Node.js 可以让很多操作同时发生但是不会阻塞用户执行操作的关键。 第二段代码片段就是回调函数被调用的时候真正执行的代码。这个回调函数就在 MongoDB 数据库中更新一条记录。 那么什么是 promise 呢？promise 就是 Node.js 中回调函数的一个改进。在开发的时候，我们可能遇到这样的场景，我们可能需要将多个回调函数嵌套起来。这种情况在一段时间后会变得有些杂乱和难以维护。简单的说，promise 就是来解决回调的这些问题的一个改进版。 promise 的基本语法就像下面这样： 12var promise = doSomethingAsync();promise.then(onFullfilled, onRejected); doSomethingAsync指的是任何执行某些异步操作回调或者匿名函数 这一次，当定义回调的时候，有一个叫做promise的值返回给我们 当一个 promise 返回的时候，它有两个输出。这个由then clause来定义。这个操作要么成功，这里通过onFullfilled参数来表示，要么出错，这里通过onRejected参数来表示。 注意: 所以 promise 的关键是这个返回值。当我们在 Node.js 中处理正常的回调的时候，并没有返回值的概念。因为有了这个返回值，我们对回调函数有了更多的控制权。 回调到 promise现在让我们看一个例子，看看我们在 Node.js 应用中是如何使用 promises 的。为了能够在 Node.js 的应用程序中使用 promise ,这个 promise 模块首先需要下载和安装。 接下来我们用 promises 来修改我们的代码，来更新 Employee 集合中的 Employeename。 安装 npm 模块 为了能够在 NodeJS 应用中使用 promise, 我们需要安装这个 promise 模块，运行下面的命令npm install promise 修改代码来引入 promise 代码解释： 第一部分是包含这个promise模块，让我们能够在代码中可以使用 promise 的功能。 现在我们可以在 MongoClient.connect函数后面添加then函数啦。所以，这段代码的意思是当建立数据库连接之后，我们需要执行定义在then里面的代码片段。 最后，我们定义了执行更新操作的代码片段 注意： 如果你现在检查 MongoDB 数据库，你会发现如果Martin雇员的名字存在，它会被更新成Mohan. 如果要检查是否在数据库中正确插入，你需要执行下面 MongoDB 的命令。 use EmployeeDB db.Employee.find({EmployeeName:mohan}) 第一个命令是保证你连上 EmployeeDB 的数据库。第二个命令是查找名字为 Mohan 的雇员的纪录 处理嵌套的 promises当我们定义 promises 的时候，需要注意的是then方法本身返回的也是一个 promise。所以，某种意义上来说 promises 可以嵌套或者链式调用。 下面的例子中，我们使用链式调用来定义了两个回调函数。两个都向数据库插入了一条记录。 注意：链式调用是把一个方法的执行链接到另一个上的概念。假如你的应用有两个方法分别叫做methodA和methodB.并且逻辑是methodB要在methodA之后调用，这个时候你就可以把这种执行顺序通过在methodA之后直接调用methodB来链接起来。 这个例子需要注意的关键是通过使用嵌套 promises 使得代码变得更简洁，可读和可维护了。 代码解释： 我们定义了两个then语句来实现在一个执行完之后再执行另一个。第一个then语句，我们将包含数据库连接的db作为参数传递给它。接下来我们通过使用db连接的属性collection来插入一条记录。这个insertOne方法被用来插入一个真正的文档对象给Employee集合。 接下来我们使用第二个then语句来向数据库插入另一条记录。 如果你现在查看 MongoDB 数据库，你会在数据库中找到这两条记录。 通过 BlueBird 库来生成 promisesBluebird 是一个功能完善的 promise 库。Bluebird 最重要的特性是它能够 promisify其他Node模块来异步地使用它们。Promisify 是一个应用在回调函数上的概念。这个概念用来保证每一个回调函数会返回一些值。 所以，如果一个 NodeJS 模块包含了一个不返回任何值的回调函数，如果我们 Promisify这个node模块，那么所有在这个模块内部的函数都会被自动修改保证它有返回值。 所以，你可以使用 Bluebird 让 MongoDB 模块异步运行。这样就从另一层面上提高了写 Node.js 应用程序的舒适性。 我们接下来就看一个如果使用 bluebird 模块的例子。 我们的例子首先建立一个到 EmployeeDB 数据库中 Employee collection的一个连接。如果接下来连接建立好了，它就会获取所有的集合中的记录并且在控制台中打印出来。 安装 npm 模块 要在 Node 应用程序中使用 Bluebird，必须包含这个模块，运行下面的命令： npm install bluebird 接下来就是包含这个 bluebird 模块，然后 promise 化整个 MongoDB 模块。这里的 promise 化，我们的意思是 bluebird 确保每一个定义在 MongoDB 类库中的方法都会返回一个 promise。 代码解释： require命令是用来包含这个 Bluebird 库的。 通过使用 Bluebird 的 promisifyAll()这个方法来创建 MongoDB 模块中每一个方法的异步版本。这确保每一个 MongoDB 模块的方法都会在后台中运行，并且确保 MongoDB 库的每一个方法都会返回一个 promise。 最后一步就是连接数据库，获取集合中的所有记录然后在控制台展示它们。 代码解释： 你会发现我们这里使用connectAsync方法而不是正常的connect方法来连接数据库。Bluebird 是通过给每一个方法添加 Async 关键字来区分返回 promise 和不返回 promise 的调用。所以我们并不能保证没有 Async 关键字的方法会有返回值。 和connectAsync类似，我们现在使用findAsync方法来返回所有在 MongoDB 数据库中 Employee集合中的记录。 最后，如果这个 findAsync方法成功返回一个 promise ，我们接下来就可以定义一段代码来遍历集合中的每一个记录然后把它们的内容打印出来。 如果上面的步骤正确的执行，所有在Employee集合的文档都会被打印到控制台，就像下面这样. 创建一个自定义的 promise一个自定义promise可以通过一个叫做q的 node 模块来创建。这个q模块需要通过 node 包管理工具来下载和安装。在使用q这个库之后，这个denodeify方法被调用之后会让任何函数变成一个会返回 promise 的函数。 下面的例子中，我们首先创建一个简单的函数叫做Add，它会把两个数加起来。我们要让这个函数转化为一个返回 promise 对象的函数. 一旦转化成功之后，我们就会通过这个Add函数返回的 promise 来在控制台中展示信息 接下来让我们按照下面的方法来创建一个自定义的返回 promise 对象的方法。 安装 npm 模块 要使用q这个模块，我们需要在 NodeJs 应用程序中包含它。安装这个q模块，我们可以运行下面的命令 npm install q 定义下面的代码来创建自定义的 promise 代码解释： 第一段的作用是通过require关键字包含这个q库，通过使用这个库，我们就能够定义任何函数来返回一个回调函数。 我们创建了一个叫做 Add 的函数，它会把两个有变量a和b表示的数字加起来，结果保存在c中。 我们使用q库来denodeify（用来将任何函数转化成能够返回 promise 的函数的方法）我们的Add函数。 现在我们调用这个Add函数就能够返回一个 promise ，因为我们之前denodeify了这个Add函数 这里的then关键词被用来表示当函数成功执行之后在控制台中展示Addition function completed. 当上面的代码执行之后，就会在控制台输出下面的内容 什么是 generatorsgenerators 最近在 Node.js 中变得相当有名，这也许和它们能够做的事情有关。 Generators 是一个能够让函数执行挂起，并且在后面的某个时间点恢复 Generators 在实现比如说懒执行的概念的时候非常有用。这基本意味着通过挂起操作和随心所欲地恢复执行，我们能够只有在我们需要的时候取数据。 Generators 有下面两个关键字: Yield 方法：这个yield方法是在要在停止函数执行的时候调用的，函数就在yield方法被调用的那一行停止。 Next 方法：这个next方法从主应用调用去恢复拥有yield方法的函数的执行。这个函数会一直执行到遇到下一个yield方法或者直到函数的结束. 让我们看一下下面的例子看看 generators 是怎么使用的。 下面的例子中，我们会有一个把两个数字相加的Add函数，但是但是我们会在函数中不同的地方停止函数的执行来展示 generators 是如何使用的。 代码解释： 第一步是定义我们的 generator 函数。注意这里是通过在 function 关键字后面添加*完成的。接下来我们定义一个叫做Add 的函数，接受一个x作为参数. 这个yield关键字只用在 generators 中。这让它拥有能够在函数的人和位置暂停的能力。所以在这里，这个函数会一直停止，知道我们调用next()函数，在第4步会调用。在这里，x的值会变成6并且函数的执行会停止。 这里就是我们调用 generator 函数并且把 5 作为参数传给这个函数的地方。 一旦我们调用next()方法，Add()函数会恢复执行。当我们执行到下面这一个语句var y = yield(null)的时候又会停止执行。(此时返回的 value 是 6,而不是上面说的 null) 再次调用next()方法，一只执行到return x + y;结束。（此时返回的 value 是 null,而不是上面说的 11）。 再次调用next()方法，会直接返回 11. 回调 VS generators Generators 被用来解决一个叫做回调hell的问题。有些时候在 Node.js 应用中，回调函数嵌套的如此之深以至于它变得太复杂而不能使用回调。 这个时候 Generators 就派上用场啦。一个最常用的例子就是创建定时器函数。 让我们看看下面的例子来看看 generators 是如何证明它比回调更有用的。 我们的例子只创建一个简单的时间延迟函数。我们接下来会在 1s,2s,3s之后调用这个函数。 创建一个回调函数有必要的时间延迟的代码 代码解释： 这里我们创建了一个叫做Timedelay的函数，里面包含一个叫做 ptime 的参数，这个可以让我们等待给定的时间来执行回调 下一步就是创建一条消息，告诉用户说这个应用程序会暂停这么多时间 现在我们来看一下如果我们包含很多回调的代码。假如我们想要在每次调用之后都增加 1s 再调用回调函数，下面的代码就是我们需要的用来实现的回调代码。 代码解释： 我们以 1000 作为参数调用 Timedelay 函数 接下来，我们以 2000 作为参数调用 Timedelay 函数 最后，我们以 3000 作为参数调用 Timedelay 函数 现在我们来看看如何通过 generators 来实现上面一样的功能。","raw":null,"content":null,"categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://wangfulin.github.io/categories/Node-js/"},{"name":"javascript","slug":"Node-js/javascript","permalink":"http://wangfulin.github.io/categories/Node-js/javascript/"}],"tags":[{"name":"javascript, Node.js","slug":"javascript-Node-js","permalink":"http://wangfulin.github.io/tags/javascript-Node-js/"}]},{"title":"npm常用命令解析","slug":"npm","date":"2014-10-19T16:00:00.000Z","updated":"2016-04-28T08:00:08.000Z","comments":true,"path":"2014/10/20/npm/","link":"","permalink":"http://wangfulin.github.io/2014/10/20/npm/","excerpt":"","keywords":null,"text":"npm install npm install &lt; packagename &gt;,比如npm install jquery npm install &lt; packagename &gt;@&lt; version &gt;,比如npm install jquery@2.1.3 npm install &lt; packagename &gt;@&lt; version-range &gt;,比如 npm install jquery@”&gt;=1.0.1 &lt;3.0.0” npm install &lt; packagename &gt;@&lt; tagname&gt;,比如npm install jquery@latest npm install git地址,比如 npm install git@github.com:jquery/jquery npm install还可以加一些参数比如-g,–save,–save-dev，分别表示全局安装，将依赖添加到package.json的dependencies，添加到devDependencies。 npm remove npm update npm config npm config set，比如npm config set registry http://registry.cnpmjs.org npm config get，比如npm config get registry npm config list npm config ls -l,显示所有的默认设置 npm config edit，更改配置文件 npm init，可以通过命令行来初始化package.json文件 npm list，显示所有安装的包 npm list -g 全局安装的模块 npm list -g –depth=0 不显示模块的依赖 npm root 查看当前包的安装路径 npm root -g 查看全局包的安装入境 npm [packagename] help,获取帮助 npm outdated，查看所有过时的包 npm prune，移除不再依赖的包 npm search,查找相应的包 npm cache clean,删除cache,即npm config get cache这个文件夹存的缓存。","raw":null,"content":null,"categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://wangfulin.github.io/categories/Node-js/"},{"name":"npm","slug":"Node-js/npm","permalink":"http://wangfulin.github.io/categories/Node-js/npm/"}],"tags":[{"name":"npm, Node.js","slug":"npm-Node-js","permalink":"http://wangfulin.github.io/tags/npm-Node-js/"}]},{"title":"<译> React的双向绑定","slug":"react-advanced-two-way-bind","date":"2014-09-19T16:00:00.000Z","updated":"2016-04-28T08:00:24.000Z","comments":true,"path":"2014/09/20/react-advanced-two-way-bind/","link":"","permalink":"http://wangfulin.github.io/2014/09/20/react-advanced-two-way-bind/","excerpt":"","keywords":null,"text":"原文：Advanced Two Way Binding for React React是一个很好的库，它能够让开发web应用变得更简单。 但是，从Angular转过来的开发者第一眼看到的就是默认是不支持双向绑定的。这也是一些开发者不想尝试它的原因。 尽管双向绑定是一个很cool的特性，但是事实上它并不是大部分应用需要的。然后，它有些时候也是很有用的。 今天，我会向你展示一个我几乎每天都会用到的现实应用实例，没有数据的双向绑定，开发这个应用就会像噩梦一般。 to be continuing","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"},{"name":"React","slug":"javascript/React","permalink":"http://wangfulin.github.io/categories/javascript/React/"}],"tags":[{"name":"javascript, React","slug":"javascript-React","permalink":"http://wangfulin.github.io/tags/javascript-React/"}]},{"title":"<译> 使用负边距权威指南","slug":"the-definitive-guide-to-using-negative-margin","date":"2014-08-19T16:00:00.000Z","updated":"2016-04-28T08:00:57.000Z","comments":true,"path":"2014/08/20/the-definitive-guide-to-using-negative-margin/","link":"","permalink":"http://wangfulin.github.io/2014/08/20/the-definitive-guide-to-using-negative-margin/","excerpt":"","keywords":null,"text":"原文: The Definitive Guide to Using Negative Margins 自从1998年CSS2作为推荐以来，表格的时候渐渐退去，成为历史。正因为此，从那以后CSS布局成为了优雅代码的代名词。 对于所有设计师使用过的CSS概念，负边距作为最少讨论到的定位方式要记上一功。这就像是在线纹身-每个人都会做，但是没有人会谈论它。（It’s like an online taboo—everyone’s doing it, yet no one wants to talk about it.） 为其正名我们都使用过CSS得外边距，但是当谈到负边距的时候，我们好像往差的方向发展啦。在网页设计中负边距的使用出现了两种极端，一种特别喜欢它，也有一些人认为这完全就是魔鬼的作品。 负边距的使用如下： #content {margin-left:-100px; } 负边距通常在小范围使用。但是接下来你会看到，它能做的事情很多。下面是一些你应该知道的关于负边距的事情： 他们是完全有效的CSS 这不是在跟你开玩笑。W3C甚至都说，在外边框中使用负边距是允许的。要了解更多可以点击这边文章 负边距不是在hack 这是尤其正确的。正是因为没有很好地了解负边距才是导致各种奇怪的问题。只有在被用来解决其他地方的bug的时候才是hack 它符合正常的文档流 当负边距使用在没有浮动的元素上时并不会破坏正常的文档流。所以付过你使用负边距把元素向上微调的话，所有后面的元素也会向上微调。 它是相当好的兼容性 负边距基本上被所有现代的浏览器支持（IE6的大部分情况也是） 当使用了float之后，会有不同的表现 负边距不是你平常使用的属性，所以使用的时候要格外小心。 Dreamweaver不理解它 负边距不会在DW的设计窗口展示出效果。那你为什么还用DW的设计窗口查看效果呢？ 与其共事负边距如果可以正确的使用的话它的功能是很强大的。有两种场景负边距是很重要的。 在static元素中使用负边距 一个static元素是一个没有使用过float的元素。上面的图片展示了一个static的元素使用负边距之后的情况。 当一个static元素在top/left使用负边距时，它把元素向这个特定的方向拉，比如 /* Moves the element 10px upwards */ #mydiv1 {margin-top:-10px;} 但是当你将负边距设置为相对bottom/right时，它并不会把元素向下或右拉，相反，它会把后面的元素往里面拉，从而覆盖自己。 /* * 所有在#mydiv1后面的元素都会向上 * 移动10px，而#mydiv1一点都不会移动 */ #mydiv1{margin-bottom:-10px;} 如果宽度没有设置，左右负边距会把元素向两个方向拉以增加宽度。在这里margin的作用相当于padding 在浮动中使用负边距加入下面就是我们的html代码： &lt;div id=&quot;mydiv1&quot;&gt;First&lt;/div&gt; &lt;div id=&quot;mydiv2&quot;&gt;Second&lt;/div&gt; 如果对一个浮动的元素使用负边距，它会产生一个空白，其他元素就可以覆盖这一部分。这个技巧可以很好地用户流式布局。比如有一列宽度100%，另一列有固定的宽度，比如说100px。 /* A negative margin is applied opposite the float */ #mydiv1 {float:left; margin-right:-100px;} 如果两个元素都使用了左浮动并且设置margin-right:-20px。#mydiv2会把#mydiv1看成宽度缩小20px（所以会覆盖一部分），但是有趣的是#mydiv1并不会有任何变化，而是依然保持原先的宽度。 如果负边距和宽度一样大的话，它就会被完全覆盖掉。因为外边距，内边距，边框和内容加起来等于元素的宽度。如果负外边距等于元素的宽度的话，那么该元素的宽度就会变成0px。 学以致用既然我们知道使用负边距在CSS2中是有效的，使用它可以给我们提供一些非常有趣的CSS技巧。 把单个列表变成三列 如果你有一个列表垂直方向太长了，为什么不把它分成几列呢？负边距可以让你在不增加任何浮动和标签的情况下完成。你会发现用负边距实现这个是多么地简单，就像下面： HTML &lt;ul&gt; &lt;li class=&quot;col1&quot;&gt;Eggs&lt;/li&gt; &lt;li class=&quot;col1&quot;&gt;Ham&lt;li&gt; &lt;li class=&quot;col2 top&quot;&gt;Bread&lt;li&gt; &lt;li class=&quot;col2&quot;&gt;Butter&lt;li&gt; &lt;li class=&quot;col3 top&quot;&gt;Flour&lt;li&gt; &lt;li class=&quot;col3&quot;&gt;Cream&lt;/li&gt; &lt;/ul&gt; CSS ul {list-style:none;} li {line-height:1.3em;} .col2 {margin-left:100px;} .col3 {margin-left:200px;} .top {margin-top:-2.6em;} /* the clincher */ 通过对.top的添加margin-top:-2.6em。所有的元素会完美的对齐好。使用负边距会比使用相对定位好很多，因为你只需要给新的一列的第一个元素添加负边距即可。酷吧，哈哈哈 重叠来强调 故意重叠元素也是一种很好地设计隐喻。重叠效果可以增强深度感从而为突出特定元素。一个很好地例子就像上图一样，通过重叠来吸引注意力。只需要使用z-index属性和一点小创意你就可以做到。 惊艳的3D文本效果 这是一个精致的技巧。通过使用两个视图的两种颜色创建safari一样有点倾斜的效果。然后通过负边距来把其中一个叠加到另一个上面，保持1到2像素的偏移。这样你就可以二道可选的，机器友好的倾斜字体。就不需要浪费很多贷款来加载大的图片来实现这个效果啦 简单的两列布局负边距也是在流式布局中创建简单一列宽度固定，一列内容为宽度的100%的两列布局的好方法。 HTML &lt;div id=&quot;content&quot;&gt; &lt;p&gt;Main content in here&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;sidebar&quot;&gt; &lt;p&gt;I’m the Sidebar! &lt;/p&gt; &lt;/div&gt; CSS #content {width:100%; float:left; margin-right:-200px;} #sidebar {width:200px; float:left;} 哈哈，这样你就得到了一个简单的两列布局。它也能在IE6完美的渲染出来。现在为了让#sidebar不要被#content给掩盖，只要简单的加上： /* Prevent text from being overlapped */ #content p {margin-right:210px;} /* It’s 200px + 10px, the 10px being an additional margin.*/ 当适当的使用的时候，负外边距能够提供一个灵活的文档结构，完爆table的布局。灵活的文档布局是一种可访问性和SEO的技巧，通过它能够让你根据你的关注点以任意顺序组织你的html代码。这里有一个文章讨论了负边距在多列布局中的应用。 微调元素这是负外边距最常也是最简单的使用方式。假如你把第十个div插入到9个其他的div中，不知道什么原因没有正确的排列，使用负边距来调整这个div就不需要改变其他9个div了，很方便。 解决bug文本和链接问题在float中使用负边距可能会在旧的浏览器造成一些问题，比如下面的这些： 让链接不可点击 文本变得很难选择 失去焦点的时候按tab键失效 解决方法：只要添加position:relative，就可以啦。 ### 图片被剪切啦 如果你运气不好刚好在办公室使用IE6，当遇到覆盖和浮动的时候内容有些时候回突然被剪切掉。 解决方法：同样的只要给浮动元素加上position:relative，所有的问题就解决啦。 结论负外边距能够在不使用任何额外标签的情况下定位元素让它在现在网页设计中占有一席之地。随着更多的用户使用更新的浏览器（包括IE8)，未来使用这些技巧的网站会变得更加有前景。 ## 资源链接 更多关于负边距的信息可以在看下面的链接： Search This Severn Solutions","raw":null,"content":null,"categories":[{"name":"CSS","slug":"CSS","permalink":"http://wangfulin.github.io/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://wangfulin.github.io/tags/css/"}]},{"title":"<译> 清楚地了解javascript中的`this`并且掌握它","slug":"Understand-javascript-this-with-clarity-and-master-it","date":"2014-07-19T16:00:00.000Z","updated":"2016-04-28T08:01:05.000Z","comments":true,"path":"2014/07/20/Understand-javascript-this-with-clarity-and-master-it/","link":"","permalink":"http://wangfulin.github.io/2014/07/20/Understand-javascript-this-with-clarity-and-master-it/","excerpt":"","keywords":null,"text":"原文：Understand Javascript’s “this” With Clarity,and Master It (同时也学一下所有this最容易被误解的场景) Javascript中这个this关键词同时会让新手和有经验的人困惑。这篇文章的目的就是把它彻底地讲清楚。当我们看完这篇文章的时候，this会成为javascript当中我们从来不用担心的那部分啦。我们会懂得如何在每一个场景正确地使用this，包括在一些最让人迷惑最诡异的场景。 我们使用this的方式就像自然语言英语和法语使用主语一样。我们这样写：“约翰跑得很快，因为他想赶上火车。”注意主语他的使用。我们也能这样写：“约翰跑得很快，因为约翰想赶上火车。”我们在这种情况下一般不会重复使用约翰。因为如果我们这样做的话，我们的家人，朋友，同事会抛弃我们的。是的，他们会的。当然，也许不是你的家庭，但是像那些有钱有地位的朋友和同时会的。javascript中也会用这种优雅的方式，我们使用this关键词作为对对象的简称和引用。也就是说，场景的主题或者正在执行的代码的主题。考虑下面的例子： var person={ firstName:&quot;penelope&quot;, lastName:&quot;Barrymore&quot;, fullName:function(){ //Notice we use &quot;this&quot; as we used &quot;he&quot; in //the example sentence earlier console.log(this.firstName+&quot; &quot;+this.lastName); // We could have also written this: console.log(person.firstName+&quot; &quot;+person.lastName); } } 如果我们使用person.firstName和person.lastName，就像上面的例子一样，我们的代码会变得不清晰。考虑到有可能有另外一个全局变量的名字是person（我们可能注意或者没注意到）。然后，对person.firstName的引用可能会尝试从person这个全局变量里面获取属性。这可能会导致很难debug的错误。所以我们使用this关键词不仅仅只是为了美感，而且也为了能够精确。它的使用事实上让我们的代码变得更加清晰，就好像主语他让我们的句子变得更清楚一样。它告诉我们我们正在指代句子开始特定的那个约翰。 就好像主语他被用来指代前面那个人一样，这个this关键词类似地也被用来指代这个函数所绑定的对象。这个this关键词不仅指代这个对象，同时也包含了这个对象的值。就好像这个主语一样，this被用来作为这个上下文的对象的指代。下面我们会了解到更多。 Javascript的this关键词基础首先，你要知道在javascript中所有的函数都是有属性的，就像对象有属性一样。并且，当函数执行的时候，它会获得这个this属性，","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/tags/javascript/"}]},{"title":"<译> Web Storage初探","slug":"web-storage-primer","date":"2014-06-19T16:00:00.000Z","updated":"2016-04-28T08:01:14.000Z","comments":true,"path":"2014/06/20/web-storage-primer/","link":"","permalink":"http://wangfulin.github.io/2014/06/20/web-storage-primer/","excerpt":"","keywords":null,"text":"Web Storage是相对比较新的一种可以将数据存储在用户电脑（客户端）的一种方式。 Web Storage给网站/应用提供了很多好处。比如，Web Storage可以用来跨网站/应用监测用户的行为而不需要服务端脚本和数据库。Web Storage也能在用户即使突然断网的情况下保存一部分web应用的能力，让你不会因为网络连接的问题受到影响 Web Storage vs. Cookies传统的用来在客户端保存数据的方式是通过HTTP cookies。 Web Storage和cookies之间存在着很多的区别。让我们把注意力放在这两种客户端数据存储的方法的真正的区别上。 存储原理Cookies是一种结构化的数据，是由web服务器返回给请求的一个服务器响应的一部分。Cookie可以通过设置HTTP响应头来进行设置。无论什么时候发送请求，浏览器都会把cookie作为请求头的一部分返回给服务器。 简单的来说，请求发送的目的是为了能够更新cookie里面的值。同时，无论数据有没有改变，cookies也总是会占据HTTP响应头的一部分。 另一方面，Web Storage的创建和管理完全是由客户端控制的。因此，尽管有服务器的参与有很多其他的优势，但Web Storage还是避免了web服务器的参与。这个方法产生了很多有益的结果，最明显的莫过于理论上导致了更好的web性能 相关：Web性能文章: 同时，因为Web Storage可以在没有HTTP请求/响应的情况下工作（摆脱了网页初始与服务器的交互），在良好的实现情况下，存储在用户浏览器的数据可以在失去网络连接的情况下也能安全的更新和修改。 不同的浏览器实例Web Storage能够解决用户开启多个浏览器窗口/标签的同步问题。在一个浏览器窗口在存储或者更新数据能够同时在其他浏览器窗口上同步，只要其他浏览器窗口在同一个网站上。 Cookies，相反，设计之初就不是用来处理设计多个浏览器窗口的情况。 存储大小限制HTTP cookies和Web Storage对存储大小的限制在不同浏览器之间是不同的。但是，一般为了能够好的跨浏览器支持把存储大小限制在4.0KB左右是最佳的实践方案。 （这里有一种cookie测试工具可以让你测试浏览器的cookie的存储大小限制） W3C Web Storage标准并没有推荐一个默认的存储限制，让浏览器自己决定。但是，现实中Web Storage完虐cookies的4.0KB的限制，一般情况下对于Web Storage对象的限制时5MB左右。 也就是说，Web Storage的大小限制是cookies的124527%倍那么大。 （这里也有一种Web Storage测试工具可以让你测试浏览器Web Storage的存储大小限制） Storage的种类Web Storage有两种方式来存储客户端数据：sessionStorage和localStorage. Web Storage 存储数据的生命周期 数据结构 数据类型 sessionStorage 只在回话中保存 键值对 字符串 localStorage 持久保存 键值对 字符串 sessionStoragesessionStorage是设计用来保存浏览器会话这个时间段的客户端数据的。换句话说数据只在用户还在网站浏览的时候才保存起来。 sessionStorage在实践中主要用来暂时的数据 存储。比如说，用户在网页表单上的输入能够在用户浏览器会话的阶段保存在sessionStorage对象当中。这样的话，数据就能够在浏览的整个过程中获得到而不需要把数据存储到服务器当中。也就是说，当用户不小心关闭或者刷新浏览器窗口，暂时的数据存储可以防止用户不得不重复输入数据。 localStorage从实现的角度来说，localStorage和sessionStorage的实现方式是基本类似的。 localStorage和sessionStorage分享一套javascript方法（比如说：getItem,setItem等等），并且它也以键值对的方式存储数据。 但是，把数据存储在localStorage对象上意味着数据可以在用户的会话之间一直保存着。换句话说，数据可以在用户下一次访问这个网站的时候依然可以获取到。 Web Storage的浏览器支持Caniuse.com的结论是Web Storage有良好的浏览器支持。 Web Storage浏览器支持表 浏览器 版本 Internet Explorer IE8及IE8以上 Mozilla Firefox Firefox 3.5及以上 Google Chrome Chrome 4及以上 Apple Safari Safari 4及以上 Opera Opera 11.5及以上 目前，Web Storage标准是W3C Candidate Recommendation.总共有五个级别的推荐。”Candidate Recommendation”是这五个级别中的第三个级别。目前的Web Storage已经相当成熟因为这已经不是一个工作草案啦，但是与此同时，这个也不是最终的方案。 支持旧的没有Web Storage这个特性的浏览器可以通过使用polyfill来支持。对于localStorage的支持可以选择Store.js。 ## 数据隐私和安全考虑 Ｗeb Storage和cookies有一样的禁止跨域的策略。这意味着一个网站的Web Storage不能被其他网站访问。这对于数据安全来说是有益的。但是这也导致了我们在需要子域的时候出现问题。对于这个问题，有其他的解决方案，比如由Zendesk开发的一个开源包Cross-Storage。 就像任何其他的客户端数据存储机制一样，保护存储的数据也是一个很重要的需要考虑的点。保存用户私密或者敏感的数据是不推荐的。这也让能够接触设备的人更方便的获取到本地数据。尤其是在一些其他人可以用公共的网络环境比如大学，图书馆，工作电脑等访问你的网站的地方更应该格外小心。 数据完备性也是一个考虑因素。必须要有在存储事务失败的时候的解决方案。当用户的Web Storage被关闭时候，或者当用户的存储空间不足的时候，或者超过浏览器的Web Storage限制的时候都有可能造成失败。Web Storage规范说明了当触发存储失败事件的标准的错误/警告输出，比如QuotaExceededError异常。 IndexedDB怎么样呢？对于客户端存储来说，Indexed Database API(IndexedDB)提供了很多可以从Web Storage衍生出来的相同的有点。但是IndexedDB不是Web Storage规范的一部分所以这也超出了我们所要讨论的范围。 但是。IndexedDB也很值得我们简单的聊一下，因为它和Web Storage实现有很多共享的特点以及未来可能有联系的可能。 通过IndexedDB存储数据相对于Web Storage来说可能会更加复杂一些。但是，它也打开了通往更加复杂数据结构和关系的大门。 通过IndexedDB，数据会像你喜欢的客户端数据管理系统比如MYSQL,MSSQL,PostgreSQL等等数据库一样通过索引存储起来 相关：最好的五中数据库管理工具 除此之外，如果你实现了一个可以处理IndexedDB数据库的查询语言，你也可以想服务端数据库一样检索数据库。 相对于IndexedDB来说，Web Storage的数据获取能力是很基础的。Web Storage只有两个内置的获取数据的方法：.getItem和.key。（除了能够可以获取Web Storage对象的length属性）。因此，当你考虑到需要更加复杂的数据存储的时候，你可以考虑IndexedDB而不是Web Storage。 原文链接web-storage-primer","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"}],"tags":[{"name":"javascript, Web Storage","slug":"javascript-Web-Storage","permalink":"http://wangfulin.github.io/tags/javascript-Web-Storage/"}]},{"title":"Great tools","slug":"web_resource_link","date":"2014-05-19T16:00:00.000Z","updated":"2016-04-28T08:01:22.000Z","comments":true,"path":"2014/05/20/web_resource_link/","link":"","permalink":"http://wangfulin.github.io/2014/05/20/web_resource_link/","excerpt":"","keywords":null,"text":"jQuery pluginslider module package tool browserify webpack grunt gulp bower yeoman Phantomjs vuejs homebrew jekyll enhanced cmd cmder library or framework angular.js react polymer resource","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/tags/javascript/"}]},{"title":"Webpapck的简介","slug":"webpack","date":"2014-04-19T16:00:00.000Z","updated":"2016-04-28T08:01:29.000Z","comments":true,"path":"2014/04/20/webpack/","link":"","permalink":"http://wangfulin.github.io/2014/04/20/webpack/","excerpt":"","keywords":null,"text":"1，什么是webpack？webpack是一个模块打包工具，主要作用是把浏览器中打包起来使用，然后它也能转换，打包，组合几乎所有的资源。 主要作用如下： 1. 可以使用`CommonJs`和`AMD`模块加载（甚至同时使用） 2. 可以创建一个整包或者几个区块进行运行时异步加载（减少初始加载时间） 3. 在编译的时候解析依赖，减少运行时的大小 4. 加载器可以在编译的时候预处理文件，比如把`coffescript`转换成`Javacript` ,`handlebars strings`转换成`compiled function`,`iamges`转换成`Base64`,等等 5. 高度模块化的插件系统可以让你的应用做任何其他想做的事情 2，如何开始？ 创建一个文件夹，比如webpacktest 创建文件entry.js document.write(“It works”); 创建文件index.html &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 运行命令webpack ./entry.js bundle.js参考链接 github-webpack webpack-github-io","raw":null,"content":null,"categories":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://wangfulin.github.io/tags/javascript/"}]}]}